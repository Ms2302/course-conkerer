{"ast":null,"code":"import e from \"axios\";\nimport n from \"js-cookie\";\nconst t = {\n  user: {},\n  tokens: {},\n  mode: \"live\"\n};\nfunction r(e) {\n  try {\n    const n = e.split(\".\")[1].replace(/-/g, \"+\").replace(/_/g, \"/\"),\n      t = decodeURIComponent(window.atob(n).split(\"\").map(e => \"%\" + (\"00\" + e.charCodeAt(0).toString(16)).slice(-2)).join(\"\"));\n    return JSON.parse(t);\n  } catch (e) {\n    console.error(\"Problem decoding JWT payload\", e);\n  }\n}\nfunction o(e) {\n  try {\n    if (!e) return !1;\n    const n = r(e);\n    return new Date(1e3 * n.exp) > new Date();\n  } catch (e) {\n    return !1;\n  }\n}\nfunction a(e) {\n  var n, t;\n  if (e) {\n    if (\"string\" == typeof e) throw new Error(e);\n    if (null != e && null != (n = e.response) && null != (t = n.data) && t.message) throw new Error(e.response.data.message);\n    throw e;\n  }\n}\nfunction i() {\n  return \"undefined\" != typeof window;\n}\nconst s = t.user;\nfunction c(e) {\n  return e.replace(/([^:]\\/)\\/+/g, \"$1\");\n}\nconst u = function (n, r, o) {\n    try {\n      const a = c(`${t.baseUrl}${n}`);\n      return Promise.resolve(e.put(a, r, o));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  },\n  d = function (n, r, o) {\n    try {\n      const a = c(`${t.baseUrl}${n}`);\n      return Promise.resolve(e.post(a, r, o));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  },\n  h = function (n, r) {\n    try {\n      const o = c(`${t.baseUrl}${n}`);\n      return Promise.resolve(e.get(o, r));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\nfunction l(e, r, o) {\n  const a = `${o}.${t.tenantId}`;\n  r = r || {\n    secure: \"live\" === t.mode,\n    sameSite: \"Lax\"\n  }, \"refresh\" === o && (r.sameSite = \"Strict\"), n.set(a, e, r);\n}\nfunction f(e) {\n  let t, r;\n  try {\n    const e = window.location.pathname,\n      n = window.location.hostname,\n      o = n.split(\".\").slice(-2).join(\".\");\n    t = [void 0, e, \"/\"], r = [void 0, n, `.${n}`, o, `.${o}`];\n  } catch (e) {\n    t = [void 0, \"/\"], r = [void 0];\n  }\n  t.map(t => {\n    r.map(r => {\n      const o = {};\n      r && (o.domain = r), t && (o.path = t), n.remove(e, o);\n    });\n  });\n}\nfunction m() {\n  f(t.tokens.accessTokenName), f(t.tokens.idTokenName), f(t.tokens.refreshTokenName), t.tokens.accessToken = void 0, t.tokens.idToken = void 0, t.tokens.refreshToken = void 0, function () {\n    for (const e in t.user) \"function\" != typeof t.user[e] && delete t.user[e];\n  }();\n}\nfunction p() {\n  return !!$.firstFactorToken;\n}\nfunction k() {\n  return $.firstFactorToken ? {\n    authorization: `Bearer ${$.firstFactorToken}`\n  } : {};\n}\nfunction w() {\n  $.secondFactors = [], $.firstFactorToken = null;\n}\nconst v = function () {\n    try {\n      return Promise.resolve(P()).then(function (e) {\n        return {\n          isLoggedIn: e,\n          needsSecondFactor: p(),\n          firstFactors: $.firstFactors,\n          secondFactors: $.secondFactors,\n          resetMfaState: w\n        };\n      });\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  },\n  P = function () {\n    return Promise.resolve(function (e, n) {\n      try {\n        var r = !!_() || !!o(t.tokens.refreshToken) && Promise.resolve(M()).then(function () {\n          return _();\n        });\n      } catch (e) {\n        return !1;\n      }\n      return r && r.then ? r.then(void 0, function () {\n        return !1;\n      }) : r;\n    }());\n  },\n  R = {\n    codeChallenge: \"\",\n    get usePkce() {\n      return !!R.codeChallenge;\n    }\n  };\nfunction g() {\n  i() && (window.localStorage.removeItem(\"uf_pkce_code_challenge\"), window.localStorage.removeItem(\"uf_pkce_code_challenge_expiresAt\"));\n}\nfunction y() {\n  if (!i()) return;\n  const e = I(\"code_challenge\");\n  if (e) return R.codeChallenge = e, function (e) {\n    if (!i()) return;\n    if (!e) return g();\n    R.codeChallenge = e;\n    const n = Date.now() + 3e5;\n    try {\n      window.localStorage.setItem(\"uf_pkce_code_challenge\", e), window.localStorage.setItem(\"uf_pkce_code_challenge_expiresAt\", n);\n    } catch (e) {}\n  }(e), !0;\n  const n = function () {\n    if (!i()) return;\n    const e = window.localStorage.getItem(\"uf_pkce_code_challenge\");\n    if (e) {\n      const n = window.localStorage.getItem(\"uf_pkce_code_challenge_expiresAt\");\n      if (n && parseInt(n, 10) > Date.now()) return e;\n    }\n  }();\n  return n ? (R.codeChallenge = n, !0) : (g(), !1);\n}\nfunction T() {\n  return R.usePkce ? {\n    code_challenge: R.codeChallenge\n  } : {};\n}\nfunction I(e) {\n  if (\"object\" == typeof window && \"object\" == typeof window.location && window.location.href && !(window.location.href.indexOf(`${e}=`) < 0)) return decodeURIComponent(window.location.href.split(`${e}=`)[1].split(\"&\")[0]);\n}\nconst U = (e, n) => {\n  !1 !== e && q(!0 !== e ? e || I(\"redirect\") || n.redirectTo || \"/\" : I(\"redirect\") || n.redirectTo || \"/\");\n};\nfunction q(e) {\n  if (!e || \"object\" != typeof document || \"object\" != typeof window) return;\n  try {\n    document && window;\n  } catch (e) {\n    return;\n  }\n  const n = document.createElement(\"a\");\n  n.href = e, n.pathname !== window.location.pathname && window.location.assign(`${n.pathname}${n.hash}${n.search}`);\n}\nconst b = function ({\n    data: e,\n    redirect: n,\n    handleUpstreamResponse: t,\n    handleMfaRequired: r,\n    handlePkceRequired: o,\n    handleTokens: a,\n    handleRedirect: i\n  }) {\n    try {\n      function s() {\n        let t;\n        function s(r) {\n          if (t) return r;\n          function s() {\n            let t;\n            function r(r) {\n              if (t) return r;\n              const o = function () {\n                if (e.hasOwnProperty(\"redirectTo\") && !1 !== n) {\n                  const n = function () {\n                    if (\"function\" == typeof i) return Promise.resolve(i(c, e)).then(function () {});\n                    U(c, e);\n                  }();\n                  if (n && n.then) return n.then(function () {});\n                }\n              }();\n              return o && o.then ? o.then(function () {\n                return e;\n              }) : e;\n            }\n            const a = function () {\n              if (e.hasOwnProperty(\"authorizationCode\")) {\n                if (!c) throw new Error(\"Missing PKCE redirect url\");\n                return \"function\" == typeof o ? Promise.resolve(o(e.authorizationCode, c, e)).then(function () {}) : (function (e, n, t) {\n                  if (!n || !e) return;\n                  R.usePkce || console.warn(\"Redirecting with a PKCE authorization code, but no PKCE challenge code is present in the client. This is unexpected.\");\n                  const r = new URL(n);\n                  r.searchParams.set(\"authorization_code\", e), g(), window.location.assign(r.href);\n                }(e.authorizationCode, c), t = 1, e);\n              }\n            }();\n            return a && a.then ? a.then(r) : r(a);\n          }\n          const u = function () {\n            if (e.hasOwnProperty(\"tokens\")) {\n              const n = \"function\" == typeof a ? Promise.resolve(a(e.tokens, e)).then(function () {}) : Promise.resolve(C(e.tokens, e)).then(function () {});\n              if (n && n.then) return n.then(function () {});\n            }\n          }();\n          return u && u.then ? u.then(s) : s();\n        }\n        const u = function () {\n          if (e.hasOwnProperty(\"firstFactorToken\")) {\n            function n() {\n              return t = 1, e;\n            }\n            const o = function () {\n              if (\"function\" == typeof r) return Promise.resolve(r(e.firstFactorToken, e)).then(function () {});\n              !function (e, n) {\n                n.isMfaRequired ? ($.firstFactorToken = e, $.secondFactors = n.authentication.secondFactors) : \"OK\" === n.message && w();\n              }(e.firstFactorToken, e);\n            }();\n            return o && o.then ? o.then(n) : n();\n          }\n        }();\n        return u && u.then ? u.then(s) : s(u);\n      }\n      let c = n || I(\"redirect\") || e.redirectTo || \"/\";\n      const u = function () {\n        if (\"function\" == typeof t) return Promise.resolve(t(e.upstreamResponse, e)).then(function () {});\n      }();\n      return Promise.resolve(u && u.then ? u.then(s) : s());\n    } catch (d) {\n      return Promise.reject(d);\n    }\n  },\n  $ = {\n    firstFactors: [],\n    secondFactors: [],\n    firstFactorToken: null\n  };\nfunction E(e) {\n  l(e.access.value, e.access.cookieOptions, \"access\"), l(e.id.value, e.id.cookieOptions, \"id\"), e.refresh && e.refresh.value && l(e.refresh.value, e.refresh.cookieOptions, \"refresh\"), N();\n}\nfunction j(e, n) {\n  try {\n    var t = e();\n  } catch (e) {\n    return n(e);\n  }\n  return t && t.then ? t.then(void 0, n) : t;\n}\nconst M = function () {\n    try {\n      const e = j(function () {\n        return Promise.resolve(function () {\n          try {\n            const e = n.get(t.tokens.refreshTokenName);\n            return Promise.resolve(j(function () {\n              return Promise.resolve(h(\"/auth/refresh\", {\n                headers: {\n                  authorization: `Bearer ${e}`\n                }\n              })).then(function ({\n                data: e,\n                status: n\n              }) {\n                if (200 !== n) throw new Error(e.message || \"Problem with request\");\n                if (e.tokens) return E(e.tokens), e;\n                throw new Error(\"Problem setting cookies\");\n              });\n            }, function (e) {\n              a(e);\n            }));\n          } catch (e) {\n            return Promise.reject(e);\n          }\n        }()).then(function () {});\n      }, function (e) {\n        console.warn(`Refresh failed: ${e.message}`);\n      });\n      return Promise.resolve(e && e.then ? e.then(function () {}) : void 0);\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  },\n  C = function (e, n) {\n    try {\n      return E(e), Promise.resolve(function ({}) {\n        return Promise.resolve();\n      }(n)).then(function () {});\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\nfunction N() {\n  [\"access\", \"id\", \"refresh\"].map(e => {\n    try {\n      const o = n.get(t.tokens[`${e}TokenName`]);\n      t.tokens[`${e}Token`] = o, \"id\" === e && o && function () {\n        if (!t.tokens.idToken) return console.warn(\"Cannot define user: missing ID token\");\n        t.user = t.user || {};\n        const e = r(t.tokens.idToken),\n          n = [\"email\", \"phoneNumber\", \"username\", \"name\", \"image\", \"data\", \"createdAt\", \"updatedAt\", \"mode\", \"userId\", \"userUuid\", \"tenantId\", \"isEmailConfirmed\", \"isPhoneNumberConfirmed\", \"confirmedEmailAt\", \"confirmedPhoneNumberAt\", \"isMfaRequired\", \"isConfirmed\"];\n        for (const r of n) {\n          if (\"update\" === r) return;\n          t.user[r] = e[r];\n        }\n      }();\n    } catch (n) {\n      console.warn(`Problem setting ${e} token.`);\n    }\n  });\n}\nfunction _() {\n  return o(t.tokens.accessToken);\n}\nt.tokens = t.tokens || {}, t.tokens.refresh = M;\nconst F = t.tokens;\nfunction O(e, n) {\n  try {\n    var t = e();\n  } catch (e) {\n    return n(e);\n  }\n  return t && t.then ? t.then(void 0, n) : t;\n}\nconst S = function ({\n    password: e,\n    existingPassword: n\n  }) {\n    try {\n      return Promise.resolve(O(function () {\n        if (!t.tokens.accessToken) throw new Error('updatePassword({ method: \"jwt\" }) was called without a JWT access token.');\n        return Promise.resolve(u(\"/auth/basic\", {\n          tenantId: t.tenantId,\n          password: e,\n          existingPassword: n\n        }, {\n          headers: {\n            Authorization: `Bearer ${t.tokens.accessToken}`\n          }\n        })).then(function ({\n          data: e\n        }) {\n          return e;\n        });\n      }, function (e) {\n        a(e);\n      }));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  },\n  z = function ({\n    uuid: e,\n    token: n,\n    password: r,\n    redirect: o,\n    handleUpstreamResponse: i,\n    handleMfaRequired: s,\n    handlePkceRequired: c,\n    handleTokens: d,\n    handleRedirect: h\n  }) {\n    try {\n      return Promise.resolve(O(function () {\n        if (n = n || I(\"token\"), e = e || I(\"uuid\"), !n || !e) throw new Error(\"Missing token or uuid\");\n        return Promise.resolve(u(\"/auth/reset\", {\n          tenantId: t.tenantId,\n          uuid: e,\n          token: n,\n          password: r\n        })).then(function ({\n          data: e\n        }) {\n          return b({\n            data: e,\n            redirect: o,\n            handleUpstreamResponse: i,\n            handleMfaRequired: s,\n            handlePkceRequired: c,\n            handleTokens: d,\n            handleRedirect: h\n          });\n        });\n      }, function (e) {\n        a(e);\n      }));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  },\n  x = function ({\n    method: e,\n    password: n,\n    existingPassword: r,\n    uuid: o,\n    token: a,\n    redirect: i,\n    handleUpstreamResponse: s,\n    handleMfaRequired: c,\n    handlePkceRequired: u,\n    handleTokens: d,\n    handleRedirect: h\n  }) {\n    try {\n      switch (e) {\n        case \"link\":\n          return z({\n            uuid: o,\n            token: a,\n            password: n,\n            redirect: i,\n            handleUpstreamResponse: s,\n            handleMfaRequired: c,\n            handlePkceRequired: u,\n            handleTokens: d,\n            handleRedirect: h\n          });\n        case \"jwt\":\n          return S({\n            password: n,\n            existingPassword: r\n          });\n        default:\n          if (a = a || I(\"token\"), (o = o || I(\"uuid\")) && a) return z({\n            uuid: o,\n            token: a,\n            password: n,\n            redirect: i,\n            handleUpstreamResponse: s,\n            handleMfaRequired: c,\n            handlePkceRequired: u,\n            handleTokens: d,\n            handleRedirect: h\n          });\n          if (t.tokens.accessToken) return S({\n            password: n,\n            existingPassword: r\n          });\n          throw new Error(\"updatePassword() was called without link credentials (token & uuid) or a JWT access token.\");\n      }\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  },\n  A = x;\nfunction L({\n  provider: e,\n  redirect: n\n}) {\n  if (!e) throw new Error(\"Missing provider\");\n  const r = function ({\n    provider: e,\n    redirect: n\n  }) {\n    if (!e) throw new Error(\"Missing provider\");\n    if (!t.tenantId) throw new Error(\"Missing tenantId\");\n    let r = `${t.baseUrl}auth/${e}/login?tenant_id=${t.tenantId}&origin=${window.location.origin}`,\n      o = n || I(\"redirect\");\n    return !1 === n && (o = \"object\" == typeof document && document.location.pathname), o && (r += `&redirect=${encodeURIComponent(o)}`), r;\n  }({\n    provider: e,\n    redirect: n\n  });\n  window.location.assign(r);\n}\nfunction B(e, n) {\n  try {\n    var t = e();\n  } catch (e) {\n    return n(e);\n  }\n  return t && t.then ? t.then(void 0, n) : t;\n}\nconst D = function ({\n  email: e,\n  name: n,\n  username: r,\n  userData: o,\n  options: i\n}) {\n  try {\n    return Promise.resolve(B(function () {\n      return Promise.resolve(d(\"/auth/link\", {\n        email: e,\n        name: n,\n        username: r,\n        data: o,\n        options: i,\n        tenantId: t.tenantId\n      })).then(function ({\n        data: e\n      }) {\n        return e;\n      });\n    }, function (e) {\n      a(e);\n    }));\n  } catch (e) {\n    return Promise.reject(e);\n  }\n};\nfunction J(e, n) {\n  try {\n    var t = e();\n  } catch (e) {\n    return n(e);\n  }\n  return t && t.then ? t.then(void 0, n) : t;\n}\nfunction W({\n  channel: e,\n  phoneNumber: n,\n  email: t\n}) {\n  if (\"sms\" !== e && \"email\" !== e) throw new Error(\"Invalid channel\");\n  if (!p()) {\n    if (\"sms\" === e && !n) throw new Error('SMS verification code requires \"phoneNumber\"');\n    if (\"email\" === e && !t) throw new Error('Email verification code requires \"email\"');\n  }\n}\nconst K = function ({\n  channel: e = \"sms\",\n  phoneNumber: n,\n  email: r,\n  name: o,\n  username: i,\n  data: s\n}) {\n  try {\n    return Promise.resolve(J(function () {\n      return W({\n        channel: e,\n        phoneNumber: n,\n        email: r\n      }), Promise.resolve(d(\"/auth/code\", {\n        channel: e,\n        email: r,\n        phoneNumber: n,\n        name: o,\n        username: i,\n        data: s,\n        tenantId: t.tenantId\n      }, {\n        headers: k()\n      })).then(function ({\n        data: e\n      }) {\n        return e;\n      });\n    }, function (e) {\n      a(e);\n    }));\n  } catch (e) {\n    return Promise.reject(e);\n  }\n};\nfunction V(e, n) {\n  try {\n    var t = e();\n  } catch (e) {\n    return n(e);\n  }\n  return t && t.then ? t.then(void 0, n) : t;\n}\nfunction G(e, n) {\n  try {\n    var t = e();\n  } catch (e) {\n    return n(e);\n  }\n  return t && t.then ? t.then(void 0, n) : t;\n}\nconst H = /((^127\\.)|(^10\\.)|(^172\\.1[6-9]\\.)|(^172\\.2[0-9]\\.)|(^172\\.3[0-1]\\.)|(^192\\.168\\.))\\d{1,3}\\.\\d{1,3}/g,\n  Q = function () {\n    try {\n      return Promise.resolve(function (e, n) {\n        try {\n          var r = Promise.resolve(h(`/tenants/${t.tenantId}/mode`)).then(function ({\n            data: e\n          }) {\n            var n;\n            return X.value = e.mode || \"test\", X.reason = Z(X.value), t.mode = X.value, n = e.authentication, t.tenantId ? n && \"object\" == typeof n && Array.isArray(n.firstFactors) ? $.firstFactors = n.firstFactors : console.warn(\"setFirstFactors: invalid factors passed.\") : console.warn(\"setFirstFactors: tried to set factors without a tenantId set.\"), e;\n          });\n        } catch (e) {\n          return n();\n        }\n        return r && r.then ? r.then(void 0, n) : r;\n      }(0, function () {\n        X.value = \"test\", t.mode = X.value;\n      }));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  },\n  X = {\n    value: \"live\",\n    reason: void 0,\n    setMode: Q\n  };\nfunction Y() {\n  const e = function (e) {\n    try {\n      const e = window.location.hostname;\n      return !(!e.match(/localhost/g) && !e.match(H));\n    } catch (e) {\n      return !0;\n    }\n  }() || !function () {\n    try {\n      return \"https:\" === window.location.protocol;\n    } catch (e) {\n      return !1;\n    }\n  }() ? \"test\" : \"live\";\n  X.value = e, X.reason = Z(e), t.mode = e;\n}\nfunction Z(e) {\n  try {\n    return \"live\" === e ? \"domain\" : \"http:\" === window.location.protocol ? \"http\" : \"https:\" !== window.location.protocol ? \"protocol\" : \"domain\";\n  } catch (e) {}\n}\nY(), t.user.update = function (e) {\n  try {\n    return !e || Object.keys(e).length < 1 ? Promise.resolve(console.warn(\"Missing user properties to update\")) : Promise.resolve(u(\"/self\", e, {\n      headers: {\n        authorization: `Bearer ${t.tokens.accessToken}`\n      }\n    })).then(function () {\n      return Promise.resolve(M()).then(function () {\n        return t.user;\n      });\n    });\n  } catch (e) {\n    return Promise.reject(e);\n  }\n}, t.user.hasRole = function (e, {\n  tenantId: n\n} = {}) {\n  try {\n    if (!t.tokens.accessToken || !t.tenantId) return !1;\n    const {\n      authorization: o\n    } = r(t.tokens.accessToken);\n    return !!o && !(!o[n = n || t.tenantId] || !o[n].roles) && o[n].roles.indexOf(e) > -1;\n  } catch (e) {\n    return !1;\n  }\n}, t.user.updatePassword = x, t.user.getTotp = function () {\n  try {\n    let e;\n    return Promise.resolve(V(function () {\n      function n(n) {\n        if (e) return n;\n        if (!t.tokens.accessToken) throw new Error(\"getTotp() was called without a JWT access token.\");\n        return Promise.resolve(h(\"/auth/totp\", {\n          headers: {\n            Authorization: `Bearer ${t.tokens.accessToken}`\n          }\n        })).then(function ({\n          data: e\n        }) {\n          return e;\n        });\n      }\n      const r = function () {\n        if (p()) return Promise.resolve(h(\"/auth/totp\", {\n          headers: k()\n        })).then(function ({\n          data: n\n        }) {\n          return e = 1, n;\n        });\n      }();\n      return r && r.then ? r.then(n) : n(r);\n    }, function (e) {\n      a(e);\n    }));\n  } catch (e) {\n    return Promise.reject(e);\n  }\n};\nlet ee = [],\n  ne = !1;\nvar te = {\n  addInitCallback: function (e) {\n    e && \"function\" == typeof e && ee.push(e);\n  },\n  init: function (n, r = {}) {\n    if (!n) return console.warn(\"Userfront initialized without tenantId\");\n    if (t.tenantId = n, t.baseUrl = r.baseUrl || \"https://api.userfront.com/v0/\", t.baseUrl.endsWith(\"/\") || (t.baseUrl += \"/\"), r.domain) {\n      t.domain = r.domain;\n      const n = `https://${t.domain}`;\n      e.defaults.headers.common[\"x-application-id\"] = n, e.defaults.headers.common[\"x-origin\"] = n;\n    }\n    t.tokens = t.tokens || {}, t.tokens.accessTokenName = `access.${t.tenantId}`, t.tokens.idTokenName = `id.${t.tenantId}`, t.tokens.refreshTokenName = `refresh.${t.tenantId}`, N(), Y(), w(), $.firstFactors = [];\n    try {\n      ee.length > 0 && ee.forEach(e => {\n        e && \"function\" == typeof e && e({\n          tenantId: n\n        });\n      }), ee = [];\n    } catch (e) {}\n  },\n  registerUrlChangedEventListener: function () {\n    if (!ne) {\n      ne = !0;\n      try {\n        history.pushState = (e = history.pushState, function () {\n          var n = e.apply(this, arguments);\n          return window.dispatchEvent(new Event(\"pushstate\")), window.dispatchEvent(new Event(\"urlchanged\")), n;\n        }), history.replaceState = (e => function () {\n          var n = e.apply(this, arguments);\n          return window.dispatchEvent(new Event(\"replacestate\")), window.dispatchEvent(new Event(\"urlchanged\")), n;\n        })(history.replaceState), window.addEventListener(\"popstate\", () => {\n          window.dispatchEvent(new Event(\"urlchanged\"));\n        });\n      } catch (e) {}\n      var e;\n    }\n  },\n  logout: function ({\n    method: e,\n    redirect: n\n  } = {}) {\n    try {\n      if (\"saml\" === e) return function () {\n        try {\n          if (!t.tokens.accessToken) throw new Error(\"Please log in to authorize your logout request.\");\n          const e = G(function () {\n            return Promise.resolve(h(\"/auth/saml/idp/token\", {\n              headers: {\n                authorization: `Bearer ${t.tokens.accessToken}`\n              }\n            })).then(function ({\n              data: e\n            }) {\n              window.location.assign(`${t.baseUrl}auth/saml/idp/logout?tenant_id=${t.tenantId}&token=${e.token}&uuid=${t.user.userUuid}`);\n            });\n          }, function (e) {\n            a(e);\n          });\n          return Promise.resolve(e && e.then ? e.then(function () {}) : void 0);\n        } catch (e) {\n          return Promise.reject(e);\n        }\n      }();\n      if (!t.tokens.accessToken) return Promise.resolve(m());\n      const r = G(function () {\n        return Promise.resolve(h(\"/auth/logout\", {\n          headers: {\n            authorization: `Bearer ${t.tokens.accessToken}`\n          }\n        })).then(function ({\n          data: e\n        }) {\n          m(), U(n, e);\n        });\n      }, function () {\n        m();\n      });\n      return Promise.resolve(r && r.then ? r.then(function () {}) : void 0);\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  },\n  mode: X,\n  setMode: Q,\n  refresh: (e, n, t) => {\n    try {\n      console.warn(\"Userfront.refresh() is deprecated and will be removed. Please use Userfront.tokens.refresh() instead.\");\n    } catch (e) {}\n    return M();\n  },\n  login: function ({\n    method: e,\n    userId: n,\n    userUuid: r,\n    email: o,\n    username: i,\n    emailOrUsername: s,\n    phoneNumber: c,\n    password: l,\n    token: f,\n    uuid: m,\n    totpCode: p,\n    backupCode: w,\n    channel: v,\n    verificationCode: P,\n    redirect: R,\n    handleUpstreamResponse: g,\n    handleMfaRequired: U,\n    handlePkceRequired: q,\n    handleTokens: $,\n    handleRedirect: E,\n    options: j\n  } = {}) {\n    try {\n      if (!e) throw new Error('Userfront.login called without \"method\" property.');\n      switch (y(), e) {\n        case \"apple\":\n        case \"azure\":\n        case \"facebook\":\n        case \"github\":\n        case \"google\":\n        case \"linkedin\":\n        case \"okta\":\n          return Promise.resolve(L({\n            provider: e,\n            redirect: R\n          }));\n        case \"password\":\n          return Promise.resolve(function ({\n            email: e,\n            username: n,\n            emailOrUsername: r,\n            password: o,\n            redirect: i,\n            handleUpstreamResponse: s,\n            handleMfaRequired: c,\n            handlePkceRequired: u,\n            handleTokens: h,\n            handleRedirect: l,\n            options: f\n          }) {\n            try {\n              return Promise.resolve(O(function () {\n                const a = {\n                  tenantId: t.tenantId,\n                  emailOrUsername: e || n || r,\n                  password: o\n                };\n                return f && f.noResetEmail && (a.options = {\n                  noResetEmail: !0\n                }), Promise.resolve(d(\"/auth/basic\", a, {\n                  headers: k(),\n                  params: T()\n                })).then(function ({\n                  data: e\n                }) {\n                  return b({\n                    data: e,\n                    redirect: i,\n                    handleUpstreamResponse: s,\n                    handleMfaRequired: c,\n                    handlePkceRequired: u,\n                    handleTokens: h,\n                    handleRedirect: l\n                  });\n                });\n              }, function (e) {\n                a(e);\n              }));\n            } catch (e) {\n              return Promise.reject(e);\n            }\n          }({\n            email: o,\n            username: i,\n            emailOrUsername: s,\n            password: l,\n            redirect: R,\n            handleUpstreamResponse: g,\n            handleMfaRequired: U,\n            handlePkceRequired: q,\n            handleTokens: $,\n            handleRedirect: E,\n            options: j\n          }));\n        case \"password-migrate\":\n          return Promise.resolve(function ({\n            email: e,\n            username: n,\n            emailOrUsername: r,\n            password: o,\n            redirect: i,\n            handleUpstreamResponse: s,\n            handleMfaRequired: c,\n            handlePkceRequired: u,\n            handleTokens: h,\n            handleRedirect: l,\n            options: f\n          }) {\n            try {\n              return Promise.resolve(function (a, m) {\n                try {\n                  var p = function () {\n                    const a = {\n                      tenantId: t.tenantId,\n                      emailOrUsername: e || n || r,\n                      password: o\n                    };\n                    return f && f.noResetEmail && (a.options = {\n                      noResetEmail: !0\n                    }), Promise.resolve(d(\"/auth/password/migrate\", a, {\n                      headers: k(),\n                      params: T()\n                    })).then(function ({\n                      data: e\n                    }) {\n                      return b({\n                        data: e,\n                        redirect: i,\n                        handleUpstreamResponse: s,\n                        handleMfaRequired: c,\n                        handlePkceRequired: u,\n                        handleTokens: h,\n                        handleRedirect: l\n                      });\n                    });\n                  }();\n                } catch (e) {\n                  return m(e);\n                }\n                return p && p.then ? p.then(void 0, m) : p;\n              }(0, function (e) {\n                a(e);\n              }));\n            } catch (e) {\n              return Promise.reject(e);\n            }\n          }({\n            email: o,\n            username: i,\n            emailOrUsername: s,\n            password: l,\n            redirect: R,\n            handleUpstreamResponse: g,\n            handleMfaRequired: U,\n            handlePkceRequired: q,\n            handleTokens: $,\n            handleRedirect: E,\n            options: j\n          }));\n        case \"passwordless\":\n          return Promise.resolve(D({\n            email: o\n          }));\n        case \"link\":\n          return Promise.resolve(function ({\n            token: e,\n            uuid: n,\n            redirect: r,\n            handleUpstreamResponse: o,\n            handleMfaRequired: i,\n            handlePkceRequired: s,\n            handleTokens: c,\n            handleRedirect: d\n          } = {}) {\n            try {\n              return Promise.resolve(B(function () {\n                if (e = e || I(\"token\"), n = n || I(\"uuid\"), e && n) return Promise.resolve(u(\"/auth/link\", {\n                  token: e,\n                  uuid: n,\n                  tenantId: t.tenantId\n                }, {\n                  headers: k(),\n                  params: T()\n                })).then(function ({\n                  data: e\n                }) {\n                  return b({\n                    data: e,\n                    redirect: r,\n                    handleUpstreamResponse: o,\n                    handleMfaRequired: i,\n                    handlePkceRequired: s,\n                    handleTokens: c,\n                    handleRedirect: d\n                  });\n                });\n              }, function (e) {\n                a(e);\n              }));\n            } catch (e) {\n              return Promise.reject(e);\n            }\n          }({\n            token: f,\n            uuid: m,\n            redirect: R,\n            handleUpstreamResponse: g,\n            handleMfaRequired: U,\n            handlePkceRequired: q,\n            handleTokens: $,\n            handleRedirect: E\n          }));\n        case \"totp\":\n          return Promise.resolve(function ({\n            totpCode: e,\n            backupCode: n,\n            userId: r,\n            userUuid: o,\n            emailOrUsername: i,\n            email: s,\n            username: c,\n            phoneNumber: u,\n            redirect: h,\n            handleUpstreamResponse: l,\n            handleMfaRequired: f,\n            handlePkceRequired: m,\n            handleTokens: p,\n            handleRedirect: w\n          } = {}) {\n            try {\n              return Promise.resolve(V(function () {\n                return Promise.resolve(d(\"/auth/totp\", {\n                  totpCode: e,\n                  backupCode: n,\n                  userId: r,\n                  userUuid: o,\n                  emailOrUsername: i,\n                  email: s,\n                  username: c,\n                  phoneNumber: u,\n                  tenantId: t.tenantId\n                }, {\n                  headers: k(),\n                  params: T()\n                })).then(function ({\n                  data: e\n                }) {\n                  return b({\n                    data: e,\n                    redirect: h,\n                    handleUpstreamResponse: l,\n                    handleMfaRequired: f,\n                    handlePkceRequired: m,\n                    handleTokens: p,\n                    handleRedirect: w\n                  });\n                });\n              }, function (e) {\n                a(e);\n              }));\n            } catch (e) {\n              return Promise.reject(e);\n            }\n          }({\n            totpCode: p,\n            backupCode: w,\n            userId: n,\n            userUuid: r,\n            emailOrUsername: s,\n            email: o,\n            username: i,\n            phoneNumber: c,\n            redirect: R,\n            handleUpstreamResponse: g,\n            handleMfaRequired: U,\n            handlePkceRequired: q,\n            handleTokens: $,\n            handleRedirect: E\n          }));\n        case \"verificationCode\":\n          return Promise.resolve(function ({\n            channel: e,\n            verificationCode: n,\n            email: r,\n            phoneNumber: o,\n            redirect: i,\n            handleUpstreamResponse: s,\n            handleMfaRequired: c,\n            handlePkceRequired: d,\n            handleTokens: h,\n            handleRedirect: l\n          } = {}) {\n            try {\n              return Promise.resolve(J(function () {\n                return W({\n                  channel: e,\n                  phoneNumber: o,\n                  email: r\n                }), Promise.resolve(u(\"/auth/code\", {\n                  channel: e,\n                  verificationCode: n,\n                  email: r,\n                  phoneNumber: o,\n                  tenantId: t.tenantId\n                }, {\n                  headers: k(),\n                  params: T()\n                })).then(function ({\n                  data: e\n                }) {\n                  return b({\n                    data: e,\n                    redirect: i,\n                    handleUpstreamResponse: s,\n                    handleMfaRequired: c,\n                    handlePkceRequired: d,\n                    handleTokens: h,\n                    handleRedirect: l\n                  });\n                });\n              }, function (e) {\n                a(e);\n              }));\n            } catch (e) {\n              return Promise.reject(e);\n            }\n          }({\n            channel: v,\n            email: o,\n            phoneNumber: c,\n            verificationCode: P,\n            redirect: R,\n            handleUpstreamResponse: g,\n            handleMfaRequired: U,\n            handlePkceRequired: q,\n            handleTokens: $,\n            handleRedirect: E\n          }));\n        case \"saml\":\n          return Promise.resolve(function () {\n            try {\n              return Promise.resolve(function (e, n) {\n                try {\n                  var r = t.tokens.accessToken ? Promise.resolve(h(\"/auth/saml/idp/token\", {\n                    headers: {\n                      authorization: `Bearer ${t.tokens.accessToken}`\n                    }\n                  })).then(function ({\n                    data: e\n                  }) {\n                    window.location.assign(`${t.baseUrl}auth/saml/idp/login?tenant_id=${t.tenantId}&token=${e.token}&uuid=${t.user.userUuid}`);\n                  }) : console.warn(\"Cannot complete SAML login without access token\");\n                } catch (e) {\n                  return n(e);\n                }\n                return r && r.then ? r.then(void 0, n) : r;\n              }(0, function (e) {\n                a(e);\n              }));\n            } catch (e) {\n              return Promise.reject(e);\n            }\n          }());\n        default:\n          throw new Error('Userfront.login called with invalid \"method\" property.');\n      }\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  },\n  resetPassword: A,\n  updatePassword: x,\n  sendLoginLink: function (e) {\n    try {\n      return Promise.resolve(B(function () {\n        return Promise.resolve(d(\"/auth/link\", {\n          email: e,\n          tenantId: t.tenantId\n        })).then(function ({\n          data: e\n        }) {\n          return e;\n        });\n      }, function (e) {\n        a(e);\n      }));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  },\n  sendResetLink: function (e) {\n    try {\n      return Promise.resolve(O(function () {\n        return Promise.resolve(d(\"/auth/reset/link\", {\n          email: e,\n          tenantId: t.tenantId\n        })).then(function ({\n          data: e\n        }) {\n          return e;\n        });\n      }, function (e) {\n        a(e);\n      }));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  },\n  sendVerificationCode: K,\n  signup: function ({\n    method: e,\n    email: n,\n    username: r,\n    phoneNumber: o,\n    name: i,\n    data: s,\n    password: c,\n    channel: u,\n    redirect: h,\n    handleUpstreamResponse: l,\n    handleMfaRequired: f,\n    handlePkceRequired: m,\n    handleTokens: p,\n    handleRedirect: w\n  } = {}) {\n    try {\n      if (y(), !e) throw new Error('Userfront.signup called without \"method\" property.');\n      switch (e) {\n        case \"apple\":\n        case \"azure\":\n        case \"facebook\":\n        case \"github\":\n        case \"google\":\n        case \"linkedin\":\n        case \"okta\":\n          return Promise.resolve(L({\n            provider: e,\n            redirect: h\n          }));\n        case \"password\":\n          return Promise.resolve(function ({\n            username: e,\n            name: n,\n            email: r,\n            password: o,\n            userData: i,\n            redirect: s,\n            handleUpstreamResponse: c,\n            handleMfaRequired: u,\n            handlePkceRequired: h,\n            handleTokens: l,\n            handleRedirect: f\n          } = {}) {\n            try {\n              return Promise.resolve(O(function () {\n                return Promise.resolve(d(\"/auth/create\", {\n                  tenantId: t.tenantId,\n                  username: e,\n                  name: n,\n                  email: r,\n                  password: o,\n                  data: i\n                }, {\n                  headers: k(),\n                  params: T()\n                })).then(function ({\n                  data: e\n                }) {\n                  return b({\n                    data: e,\n                    redirect: s,\n                    handleUpstreamResponse: c,\n                    handleMfaRequired: u,\n                    handlePkceRequired: h,\n                    handleTokens: l,\n                    handleRedirect: f\n                  });\n                });\n              }, function (e) {\n                a(e);\n              }));\n            } catch (e) {\n              return Promise.reject(e);\n            }\n          }({\n            username: r,\n            name: i,\n            email: n,\n            password: c,\n            userData: s,\n            redirect: h,\n            handleUpstreamResponse: l,\n            handleMfaRequired: f,\n            handlePkceRequired: m,\n            handleTokens: p,\n            handleRedirect: w\n          }));\n        case \"passwordless\":\n          return Promise.resolve(D({\n            email: n,\n            name: i,\n            username: r,\n            userData: s\n          }));\n        case \"verificationCode\":\n          return Promise.resolve(K({\n            channel: u,\n            email: n,\n            phoneNumber: o,\n            name: i,\n            username: r,\n            data: s\n          }));\n        default:\n          throw new Error('Userfront.signup called with invalid \"method\" property.');\n      }\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  },\n  store: t,\n  tokens: F,\n  accessToken: function () {\n    return t.tokens.accessToken = n.get(t.tokens.accessTokenName), t.tokens.accessToken;\n  },\n  idToken: function () {\n    return t.tokens.idToken = n.get(t.tokens.idTokenName), t.tokens.idToken;\n  },\n  getSession: v,\n  redirectIfLoggedIn: function ({\n    redirect: e\n  } = {}) {\n    try {\n      return Promise.resolve(v()).then(function ({\n        isLoggedIn: n\n      }) {\n        if (!n) return m();\n        if (R.usePkce) return;\n        if (e) return q(e);\n        if (I(\"redirect\")) return q(I(\"redirect\"));\n        const r = function (e, n) {\n          try {\n            var r = Promise.resolve(h(\"/self\", {\n              headers: {\n                authorization: `Bearer ${t.tokens.accessToken}`\n              }\n            })).then(function ({\n              data: e\n            }) {\n              e.tenant && e.tenant.loginRedirectPath && q(e.tenant.loginRedirectPath);\n            });\n          } catch (e) {\n            return n();\n          }\n          return r && r.then ? r.then(void 0, n) : r;\n        }(0, function () {\n          m();\n        });\n        return r && r.then ? r.then(function () {}) : void 0;\n      });\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  },\n  redirectIfLoggedOut: function ({\n    redirect: e\n  } = {}) {\n    try {\n      return Promise.resolve(v()).then(function ({\n        isLoggedIn: n\n      }) {\n        if (!n) return m(), e ? q(e) : I(\"redirect\") ? q(I(\"redirect\")) : void 0;\n      });\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  },\n  user: s\n};\nexport { te as default };","map":null,"metadata":{},"sourceType":"module"}