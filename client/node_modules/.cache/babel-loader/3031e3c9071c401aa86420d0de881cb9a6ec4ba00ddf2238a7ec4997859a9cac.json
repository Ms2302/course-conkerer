{"ast":null,"code":"import e from \"axios\";\nimport n from \"js-cookie\";\nconst t = {\n  user: {},\n  tokens: {},\n  mode: \"live\"\n};\nfunction r(e) {\n  try {\n    const n = e.split(\".\")[1].replace(/-/g, \"+\").replace(/_/g, \"/\"),\n      t = decodeURIComponent(window.atob(n).split(\"\").map(e => \"%\" + (\"00\" + e.charCodeAt(0).toString(16)).slice(-2)).join(\"\"));\n    return JSON.parse(t);\n  } catch (e) {\n    console.error(\"Problem decoding JWT payload\", e);\n  }\n}\nfunction o(e) {\n  try {\n    if (!e) return !1;\n    const n = r(e);\n    return new Date(1e3 * n.exp) > new Date();\n  } catch (e) {\n    return !1;\n  }\n}\nfunction a(e) {\n  var n, t;\n  if (e) {\n    if (\"string\" == typeof e) throw new Error(e);\n    if (null != e && null != (n = e.response) && null != (t = n.data) && t.message) throw new Error(e.response.data.message);\n    throw e;\n  }\n}\nfunction i() {\n  return \"undefined\" != typeof window;\n}\nconst s = t.user;\nfunction c(e) {\n  return e.replace(/([^:]\\/)\\/+/g, \"$1\");\n}\nconst u = function (n, r, o) {\n    try {\n      const a = c(`${t.baseUrl}${n}`);\n      return Promise.resolve(e.put(a, r, o));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  },\n  d = function (n, r, o) {\n    try {\n      const a = c(`${t.baseUrl}${n}`);\n      return Promise.resolve(e.post(a, r, o));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  },\n  h = function (n, r) {\n    try {\n      const o = c(`${t.baseUrl}${n}`);\n      return Promise.resolve(e.get(o, r));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\nfunction l(e, r, o) {\n  const a = `${o}.${t.tenantId}`;\n  r = r || {\n    secure: \"live\" === t.mode,\n    sameSite: \"Lax\"\n  }, \"refresh\" === o && (r.sameSite = \"Strict\"), n.set(a, e, r);\n}\nfunction f(e) {\n  let t, r;\n  try {\n    const e = window.location.pathname,\n      n = window.location.hostname,\n      o = n.split(\".\").slice(-2).join(\".\");\n    t = [void 0, e, \"/\"], r = [void 0, n, `.${n}`, o, `.${o}`];\n  } catch (e) {\n    t = [void 0, \"/\"], r = [void 0];\n  }\n  t.map(t => {\n    r.map(r => {\n      const o = {};\n      r && (o.domain = r), t && (o.path = t), n.remove(e, o);\n    });\n  });\n}\nfunction m() {\n  f(t.tokens.accessTokenName), f(t.tokens.idTokenName), f(t.tokens.refreshTokenName), t.tokens.accessToken = void 0, t.tokens.idToken = void 0, t.tokens.refreshToken = void 0, function () {\n    for (const e in t.user) \"function\" != typeof t.user[e] && delete t.user[e];\n  }();\n}\nfunction p() {\n  return !!$.firstFactorToken;\n}\nfunction k() {\n  return $.firstFactorToken ? {\n    authorization: `Bearer ${$.firstFactorToken}`\n  } : {};\n}\nfunction w() {\n  $.secondFactors = [], $.firstFactorToken = null;\n}\nconst v = function () {\n    try {\n      return Promise.resolve(P()).then(function (e) {\n        return {\n          isLoggedIn: e,\n          needsSecondFactor: p(),\n          firstFactors: $.firstFactors,\n          secondFactors: $.secondFactors,\n          resetMfaState: w\n        };\n      });\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  },\n  P = function () {\n    return Promise.resolve(function (e, n) {\n      try {\n        var r = !!_() || !!o(t.tokens.refreshToken) && Promise.resolve(M()).then(function () {\n          return _();\n        });\n      } catch (e) {\n        return !1;\n      }\n      return r && r.then ? r.then(void 0, function () {\n        return !1;\n      }) : r;\n    }());\n  },\n  R = {\n    codeChallenge: \"\",\n    get usePkce() {\n      return !!R.codeChallenge;\n    }\n  };\nfunction g() {\n  i() && (window.localStorage.removeItem(\"uf_pkce_code_challenge\"), window.localStorage.removeItem(\"uf_pkce_code_challenge_expiresAt\"));\n}\nfunction y() {\n  if (!i()) return;\n  const e = I(\"code_challenge\");\n  if (e) return R.codeChallenge = e, function (e) {\n    if (!i()) return;\n    if (!e) return g();\n    R.codeChallenge = e;\n    const n = Date.now() + 3e5;\n    try {\n      window.localStorage.setItem(\"uf_pkce_code_challenge\", e), window.localStorage.setItem(\"uf_pkce_code_challenge_expiresAt\", n);\n    } catch (e) {}\n  }(e), !0;\n  const n = function () {\n    if (!i()) return;\n    const e = window.localStorage.getItem(\"uf_pkce_code_challenge\");\n    if (e) {\n      const n = window.localStorage.getItem(\"uf_pkce_code_challenge_expiresAt\");\n      if (n && parseInt(n, 10) > Date.now()) return e;\n    }\n  }();\n  return n ? (R.codeChallenge = n, !0) : (g(), !1);\n}\nfunction T() {\n  return R.usePkce ? {\n    code_challenge: R.codeChallenge\n  } : {};\n}\nfunction I(e) {\n  if (\"object\" == typeof window && \"object\" == typeof window.location && window.location.href && !(window.location.href.indexOf(`${e}=`) < 0)) return decodeURIComponent(window.location.href.split(`${e}=`)[1].split(\"&\")[0]);\n}\nconst U = (e, n) => {\n  !1 !== e && q(!0 !== e ? e || I(\"redirect\") || n.redirectTo || \"/\" : I(\"redirect\") || n.redirectTo || \"/\");\n};\nfunction q(e) {\n  if (!e || \"object\" != typeof document || \"object\" != typeof window) return;\n  try {\n    document && window;\n  } catch (e) {\n    return;\n  }\n  const n = document.createElement(\"a\");\n  n.href = e, n.pathname !== window.location.pathname && window.location.assign(`${n.pathname}${n.hash}${n.search}`);\n}\nconst b = function ({\n    data: e,\n    redirect: n,\n    handleUpstreamResponse: t,\n    handleMfaRequired: r,\n    handlePkceRequired: o,\n    handleTokens: a,\n    handleRedirect: i\n  }) {\n    try {\n      function s() {\n        let t;\n        function s(r) {\n          if (t) return r;\n          function s() {\n            let t;\n            function r(r) {\n              if (t) return r;\n              const o = function () {\n                if (e.hasOwnProperty(\"redirectTo\") && !1 !== n) {\n                  const n = function () {\n                    if (\"function\" == typeof i) return Promise.resolve(i(c, e)).then(function () {});\n                    U(c, e);\n                  }();\n                  if (n && n.then) return n.then(function () {});\n                }\n              }();\n              return o && o.then ? o.then(function () {\n                return e;\n              }) : e;\n            }\n            const a = function () {\n              if (e.hasOwnProperty(\"authorizationCode\")) {\n                if (!c) throw new Error(\"Missing PKCE redirect url\");\n                return \"function\" == typeof o ? Promise.resolve(o(e.authorizationCode, c, e)).then(function () {}) : (function (e, n, t) {\n                  if (!n || !e) return;\n                  R.usePkce || console.warn(\"Redirecting with a PKCE authorization code, but no PKCE challenge code is present in the client. This is unexpected.\");\n                  const r = new URL(n);\n                  r.searchParams.set(\"authorization_code\", e), g(), window.location.assign(r.href);\n                }(e.authorizationCode, c), t = 1, e);\n              }\n            }();\n            return a && a.then ? a.then(r) : r(a);\n          }\n          const u = function () {\n            if (e.hasOwnProperty(\"tokens\")) {\n              const n = \"function\" == typeof a ? Promise.resolve(a(e.tokens, e)).then(function () {}) : Promise.resolve(C(e.tokens, e)).then(function () {});\n              if (n && n.then) return n.then(function () {});\n            }\n          }();\n          return u && u.then ? u.then(s) : s();\n        }\n        const u = function () {\n          if (e.hasOwnProperty(\"firstFactorToken\")) {\n            function n() {\n              return t = 1, e;\n            }\n            const o = function () {\n              if (\"function\" == typeof r) return Promise.resolve(r(e.firstFactorToken, e)).then(function () {});\n              !function (e, n) {\n                n.isMfaRequired ? ($.firstFactorToken = e, $.secondFactors = n.authentication.secondFactors) : \"OK\" === n.message && w();\n              }(e.firstFactorToken, e);\n            }();\n            return o && o.then ? o.then(n) : n();\n          }\n        }();\n        return u && u.then ? u.then(s) : s(u);\n      }\n      let c = n || I(\"redirect\") || e.redirectTo || \"/\";\n      const u = function () {\n        if (\"function\" == typeof t) return Promise.resolve(t(e.upstreamResponse, e)).then(function () {});\n      }();\n      return Promise.resolve(u && u.then ? u.then(s) : s());\n    } catch (d) {\n      return Promise.reject(d);\n    }\n  },\n  $ = {\n    firstFactors: [],\n    secondFactors: [],\n    firstFactorToken: null\n  };\nfunction E(e) {\n  l(e.access.value, e.access.cookieOptions, \"access\"), l(e.id.value, e.id.cookieOptions, \"id\"), e.refresh && e.refresh.value && l(e.refresh.value, e.refresh.cookieOptions, \"refresh\"), N();\n}\nfunction j(e, n) {\n  try {\n    var t = e();\n  } catch (e) {\n    return n(e);\n  }\n  return t && t.then ? t.then(void 0, n) : t;\n}\nconst M = function () {\n    try {\n      const e = j(function () {\n        return Promise.resolve(function () {\n          try {\n            const e = n.get(t.tokens.refreshTokenName);\n            return Promise.resolve(j(function () {\n              return Promise.resolve(h(\"/auth/refresh\", {\n                headers: {\n                  authorization: `Bearer ${e}`\n                }\n              })).then(function ({\n                data: e,\n                status: n\n              }) {\n                if (200 !== n) throw new Error(e.message || \"Problem with request\");\n                if (e.tokens) return E(e.tokens), e;\n                throw new Error(\"Problem setting cookies\");\n              });\n            }, function (e) {\n              a(e);\n            }));\n          } catch (e) {\n            return Promise.reject(e);\n          }\n        }()).then(function () {});\n      }, function (e) {\n        console.warn(`Refresh failed: ${e.message}`);\n      });\n      return Promise.resolve(e && e.then ? e.then(function () {}) : void 0);\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  },\n  C = function (e, n) {\n    try {\n      return E(e), Promise.resolve(function ({}) {\n        return Promise.resolve();\n      }(n)).then(function () {});\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\nfunction N() {\n  [\"access\", \"id\", \"refresh\"].map(e => {\n    try {\n      const o = n.get(t.tokens[`${e}TokenName`]);\n      t.tokens[`${e}Token`] = o, \"id\" === e && o && function () {\n        if (!t.tokens.idToken) return console.warn(\"Cannot define user: missing ID token\");\n        t.user = t.user || {};\n        const e = r(t.tokens.idToken),\n          n = [\"email\", \"phoneNumber\", \"username\", \"name\", \"image\", \"data\", \"createdAt\", \"updatedAt\", \"mode\", \"userId\", \"userUuid\", \"tenantId\", \"isEmailConfirmed\", \"isPhoneNumberConfirmed\", \"confirmedEmailAt\", \"confirmedPhoneNumberAt\", \"isMfaRequired\", \"isConfirmed\"];\n        for (const r of n) {\n          if (\"update\" === r) return;\n          t.user[r] = e[r];\n        }\n      }();\n    } catch (n) {\n      console.warn(`Problem setting ${e} token.`);\n    }\n  });\n}\nfunction _() {\n  return o(t.tokens.accessToken);\n}\nt.tokens = t.tokens || {}, t.tokens.refresh = M;\nconst F = t.tokens;\nfunction O(e, n) {\n  try {\n    var t = e();\n  } catch (e) {\n    return n(e);\n  }\n  return t && t.then ? t.then(void 0, n) : t;\n}\nconst S = function ({\n    password: e,\n    existingPassword: n\n  }) {\n    try {\n      return Promise.resolve(O(function () {\n        if (!t.tokens.accessToken) throw new Error('updatePassword({ method: \"jwt\" }) was called without a JWT access token.');\n        return Promise.resolve(u(\"/auth/basic\", {\n          tenantId: t.tenantId,\n          password: e,\n          existingPassword: n\n        }, {\n          headers: {\n            Authorization: `Bearer ${t.tokens.accessToken}`\n          }\n        })).then(function ({\n          data: e\n        }) {\n          return e;\n        });\n      }, function (e) {\n        a(e);\n      }));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  },\n  z = function ({\n    uuid: e,\n    token: n,\n    password: r,\n    redirect: o,\n    handleUpstreamResponse: i,\n    handleMfaRequired: s,\n    handlePkceRequired: c,\n    handleTokens: d,\n    handleRedirect: h\n  }) {\n    try {\n      return Promise.resolve(O(function () {\n        if (n = n || I(\"token\"), e = e || I(\"uuid\"), !n || !e) throw new Error(\"Missing token or uuid\");\n        return Promise.resolve(u(\"/auth/reset\", {\n          tenantId: t.tenantId,\n          uuid: e,\n          token: n,\n          password: r\n        })).then(function ({\n          data: e\n        }) {\n          return b({\n            data: e,\n            redirect: o,\n            handleUpstreamResponse: i,\n            handleMfaRequired: s,\n            handlePkceRequired: c,\n            handleTokens: d,\n            handleRedirect: h\n          });\n        });\n      }, function (e) {\n        a(e);\n      }));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  },\n  x = function ({\n    method: e,\n    password: n,\n    existingPassword: r,\n    uuid: o,\n    token: a,\n    redirect: i,\n    handleUpstreamResponse: s,\n    handleMfaRequired: c,\n    handlePkceRequired: u,\n    handleTokens: d,\n    handleRedirect: h\n  }) {\n    try {\n      switch (e) {\n        case \"link\":\n          return z({\n            uuid: o,\n            token: a,\n            password: n,\n            redirect: i,\n            handleUpstreamResponse: s,\n            handleMfaRequired: c,\n            handlePkceRequired: u,\n            handleTokens: d,\n            handleRedirect: h\n          });\n        case \"jwt\":\n          return S({\n            password: n,\n            existingPassword: r\n          });\n        default:\n          if (a = a || I(\"token\"), (o = o || I(\"uuid\")) && a) return z({\n            uuid: o,\n            token: a,\n            password: n,\n            redirect: i,\n            handleUpstreamResponse: s,\n            handleMfaRequired: c,\n            handlePkceRequired: u,\n            handleTokens: d,\n            handleRedirect: h\n          });\n          if (t.tokens.accessToken) return S({\n            password: n,\n            existingPassword: r\n          });\n          throw new Error(\"updatePassword() was called without link credentials (token & uuid) or a JWT access token.\");\n      }\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  },\n  A = x;\nfunction L({\n  provider: e,\n  redirect: n\n}) {\n  if (!e) throw new Error(\"Missing provider\");\n  const r = function ({\n    provider: e,\n    redirect: n\n  }) {\n    if (!e) throw new Error(\"Missing provider\");\n    if (!t.tenantId) throw new Error(\"Missing tenantId\");\n    let r = `${t.baseUrl}auth/${e}/login?tenant_id=${t.tenantId}&origin=${window.location.origin}`,\n      o = n || I(\"redirect\");\n    return !1 === n && (o = \"object\" == typeof document && document.location.pathname), o && (r += `&redirect=${encodeURIComponent(o)}`), r;\n  }({\n    provider: e,\n    redirect: n\n  });\n  window.location.assign(r);\n}\nfunction B(e, n) {\n  try {\n    var t = e();\n  } catch (e) {\n    return n(e);\n  }\n  return t && t.then ? t.then(void 0, n) : t;\n}\nconst D = function ({\n  email: e,\n  name: n,\n  username: r,\n  userData: o,\n  options: i\n}) {\n  try {\n    return Promise.resolve(B(function () {\n      return Promise.resolve(d(\"/auth/link\", {\n        email: e,\n        name: n,\n        username: r,\n        data: o,\n        options: i,\n        tenantId: t.tenantId\n      })).then(function ({\n        data: e\n      }) {\n        return e;\n      });\n    }, function (e) {\n      a(e);\n    }));\n  } catch (e) {\n    return Promise.reject(e);\n  }\n};\nfunction J(e, n) {\n  try {\n    var t = e();\n  } catch (e) {\n    return n(e);\n  }\n  return t && t.then ? t.then(void 0, n) : t;\n}\nfunction W({\n  channel: e,\n  phoneNumber: n,\n  email: t\n}) {\n  if (\"sms\" !== e && \"email\" !== e) throw new Error(\"Invalid channel\");\n  if (!p()) {\n    if (\"sms\" === e && !n) throw new Error('SMS verification code requires \"phoneNumber\"');\n    if (\"email\" === e && !t) throw new Error('Email verification code requires \"email\"');\n  }\n}\nconst K = function ({\n  channel: e = \"sms\",\n  phoneNumber: n,\n  email: r,\n  name: o,\n  username: i,\n  data: s\n}) {\n  try {\n    return Promise.resolve(J(function () {\n      return W({\n        channel: e,\n        phoneNumber: n,\n        email: r\n      }), Promise.resolve(d(\"/auth/code\", {\n        channel: e,\n        email: r,\n        phoneNumber: n,\n        name: o,\n        username: i,\n        data: s,\n        tenantId: t.tenantId\n      }, {\n        headers: k()\n      })).then(function ({\n        data: e\n      }) {\n        return e;\n      });\n    }, function (e) {\n      a(e);\n    }));\n  } catch (e) {\n    return Promise.reject(e);\n  }\n};\nfunction V(e, n) {\n  try {\n    var t = e();\n  } catch (e) {\n    return n(e);\n  }\n  return t && t.then ? t.then(void 0, n) : t;\n}\nfunction G(e, n) {\n  try {\n    var t = e();\n  } catch (e) {\n    return n(e);\n  }\n  return t && t.then ? t.then(void 0, n) : t;\n}\nconst H = /((^127\\.)|(^10\\.)|(^172\\.1[6-9]\\.)|(^172\\.2[0-9]\\.)|(^172\\.3[0-1]\\.)|(^192\\.168\\.))\\d{1,3}\\.\\d{1,3}/g,\n  Q = function () {\n    try {\n      return Promise.resolve(function (e, n) {\n        try {\n          var r = Promise.resolve(h(`/tenants/${t.tenantId}/mode`)).then(function ({\n            data: e\n          }) {\n            var n;\n            return X.value = e.mode || \"test\", X.reason = Z(X.value), t.mode = X.value, n = e.authentication, t.tenantId ? n && \"object\" == typeof n && Array.isArray(n.firstFactors) ? $.firstFactors = n.firstFactors : console.warn(\"setFirstFactors: invalid factors passed.\") : console.warn(\"setFirstFactors: tried to set factors without a tenantId set.\"), e;\n          });\n        } catch (e) {\n          return n();\n        }\n        return r && r.then ? r.then(void 0, n) : r;\n      }(0, function () {\n        X.value = \"test\", t.mode = X.value;\n      }));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  },\n  X = {\n    value: \"live\",\n    reason: void 0,\n    setMode: Q\n  };\nfunction Y() {\n  const e = function (e) {\n    try {\n      const e = window.location.hostname;\n      return !(!e.match(/localhost/g) && !e.match(H));\n    } catch (e) {\n      return !0;\n    }\n  }() || !function () {\n    try {\n      return \"https:\" === window.location.protocol;\n    } catch (e) {\n      return !1;\n    }\n  }() ? \"test\" : \"live\";\n  X.value = e, X.reason = Z(e), t.mode = e;\n}\nfunction Z(e) {\n  try {\n    return \"live\" === e ? \"domain\" : \"http:\" === window.location.protocol ? \"http\" : \"https:\" !== window.location.protocol ? \"protocol\" : \"domain\";\n  } catch (e) {}\n}\nY(), t.user.update = function (e) {\n  try {\n    return !e || Object.keys(e).length < 1 ? Promise.resolve(console.warn(\"Missing user properties to update\")) : Promise.resolve(u(\"/self\", e, {\n      headers: {\n        authorization: `Bearer ${t.tokens.accessToken}`\n      }\n    })).then(function () {\n      return Promise.resolve(M()).then(function () {\n        return t.user;\n      });\n    });\n  } catch (e) {\n    return Promise.reject(e);\n  }\n}, t.user.hasRole = function (e, {\n  tenantId: n\n} = {}) {\n  try {\n    if (!t.tokens.accessToken || !t.tenantId) return !1;\n    const {\n      authorization: o\n    } = r(t.tokens.accessToken);\n    return !!o && !(!o[n = n || t.tenantId] || !o[n].roles) && o[n].roles.indexOf(e) > -1;\n  } catch (e) {\n    return !1;\n  }\n}, t.user.updatePassword = x, t.user.getTotp = function () {\n  try {\n    let e;\n    return Promise.resolve(V(function () {\n      function n(n) {\n        if (e) return n;\n        if (!t.tokens.accessToken) throw new Error(\"getTotp() was called without a JWT access token.\");\n        return Promise.resolve(h(\"/auth/totp\", {\n          headers: {\n            Authorization: `Bearer ${t.tokens.accessToken}`\n          }\n        })).then(function ({\n          data: e\n        }) {\n          return e;\n        });\n      }\n      const r = function () {\n        if (p()) return Promise.resolve(h(\"/auth/totp\", {\n          headers: k()\n        })).then(function ({\n          data: n\n        }) {\n          return e = 1, n;\n        });\n      }();\n      return r && r.then ? r.then(n) : n(r);\n    }, function (e) {\n      a(e);\n    }));\n  } catch (e) {\n    return Promise.reject(e);\n  }\n};\nlet ee = [],\n  ne = !1;\nvar te = {\n  addInitCallback: function (e) {\n    e && \"function\" == typeof e && ee.push(e);\n  },\n  init: function (n, r = {}) {\n    if (!n) return console.warn(\"Userfront initialized without tenantId\");\n    if (t.tenantId = n, t.baseUrl = r.baseUrl || \"https://api.userfront.com/v0/\", t.baseUrl.endsWith(\"/\") || (t.baseUrl += \"/\"), r.domain) {\n      t.domain = r.domain;\n      const n = `https://${t.domain}`;\n      e.defaults.headers.common[\"x-application-id\"] = n, e.defaults.headers.common[\"x-origin\"] = n;\n    }\n    t.tokens = t.tokens || {}, t.tokens.accessTokenName = `access.${t.tenantId}`, t.tokens.idTokenName = `id.${t.tenantId}`, t.tokens.refreshTokenName = `refresh.${t.tenantId}`, N(), Y(), w(), $.firstFactors = [];\n    try {\n      ee.length > 0 && ee.forEach(e => {\n        e && \"function\" == typeof e && e({\n          tenantId: n\n        });\n      }), ee = [];\n    } catch (e) {}\n  },\n  registerUrlChangedEventListener: function () {\n    if (!ne) {\n      ne = !0;\n      try {\n        history.pushState = (e = history.pushState, function () {\n          var n = e.apply(this, arguments);\n          return window.dispatchEvent(new Event(\"pushstate\")), window.dispatchEvent(new Event(\"urlchanged\")), n;\n        }), history.replaceState = (e => function () {\n          var n = e.apply(this, arguments);\n          return window.dispatchEvent(new Event(\"replacestate\")), window.dispatchEvent(new Event(\"urlchanged\")), n;\n        })(history.replaceState), window.addEventListener(\"popstate\", () => {\n          window.dispatchEvent(new Event(\"urlchanged\"));\n        });\n      } catch (e) {}\n      var e;\n    }\n  },\n  logout: function ({\n    method: e,\n    redirect: n\n  } = {}) {\n    try {\n      if (\"saml\" === e) return function () {\n        try {\n          if (!t.tokens.accessToken) throw new Error(\"Please log in to authorize your logout request.\");\n          const e = G(function () {\n            return Promise.resolve(h(\"/auth/saml/idp/token\", {\n              headers: {\n                authorization: `Bearer ${t.tokens.accessToken}`\n              }\n            })).then(function ({\n              data: e\n            }) {\n              window.location.assign(`${t.baseUrl}auth/saml/idp/logout?tenant_id=${t.tenantId}&token=${e.token}&uuid=${t.user.userUuid}`);\n            });\n          }, function (e) {\n            a(e);\n          });\n          return Promise.resolve(e && e.then ? e.then(function () {}) : void 0);\n        } catch (e) {\n          return Promise.reject(e);\n        }\n      }();\n      if (!t.tokens.accessToken) return Promise.resolve(m());\n      const r = G(function () {\n        return Promise.resolve(h(\"/auth/logout\", {\n          headers: {\n            authorization: `Bearer ${t.tokens.accessToken}`\n          }\n        })).then(function ({\n          data: e\n        }) {\n          m(), U(n, e);\n        });\n      }, function () {\n        m();\n      });\n      return Promise.resolve(r && r.then ? r.then(function () {}) : void 0);\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  },\n  mode: X,\n  setMode: Q,\n  refresh: (e, n, t) => {\n    try {\n      console.warn(\"Userfront.refresh() is deprecated and will be removed. Please use Userfront.tokens.refresh() instead.\");\n    } catch (e) {}\n    return M();\n  },\n  login: function ({\n    method: e,\n    userId: n,\n    userUuid: r,\n    email: o,\n    username: i,\n    emailOrUsername: s,\n    phoneNumber: c,\n    password: l,\n    token: f,\n    uuid: m,\n    totpCode: p,\n    backupCode: w,\n    channel: v,\n    verificationCode: P,\n    redirect: R,\n    handleUpstreamResponse: g,\n    handleMfaRequired: U,\n    handlePkceRequired: q,\n    handleTokens: $,\n    handleRedirect: E,\n    options: j\n  } = {}) {\n    try {\n      if (!e) throw new Error('Userfront.login called without \"method\" property.');\n      switch (y(), e) {\n        case \"apple\":\n        case \"azure\":\n        case \"facebook\":\n        case \"github\":\n        case \"google\":\n        case \"linkedin\":\n        case \"okta\":\n          return Promise.resolve(L({\n            provider: e,\n            redirect: R\n          }));\n        case \"password\":\n          return Promise.resolve(function ({\n            email: e,\n            username: n,\n            emailOrUsername: r,\n            password: o,\n            redirect: i,\n            handleUpstreamResponse: s,\n            handleMfaRequired: c,\n            handlePkceRequired: u,\n            handleTokens: h,\n            handleRedirect: l,\n            options: f\n          }) {\n            try {\n              return Promise.resolve(O(function () {\n                const a = {\n                  tenantId: t.tenantId,\n                  emailOrUsername: e || n || r,\n                  password: o\n                };\n                return f && f.noResetEmail && (a.options = {\n                  noResetEmail: !0\n                }), Promise.resolve(d(\"/auth/basic\", a, {\n                  headers: k(),\n                  params: T()\n                })).then(function ({\n                  data: e\n                }) {\n                  return b({\n                    data: e,\n                    redirect: i,\n                    handleUpstreamResponse: s,\n                    handleMfaRequired: c,\n                    handlePkceRequired: u,\n                    handleTokens: h,\n                    handleRedirect: l\n                  });\n                });\n              }, function (e) {\n                a(e);\n              }));\n            } catch (e) {\n              return Promise.reject(e);\n            }\n          }({\n            email: o,\n            username: i,\n            emailOrUsername: s,\n            password: l,\n            redirect: R,\n            handleUpstreamResponse: g,\n            handleMfaRequired: U,\n            handlePkceRequired: q,\n            handleTokens: $,\n            handleRedirect: E,\n            options: j\n          }));\n        case \"password-migrate\":\n          return Promise.resolve(function ({\n            email: e,\n            username: n,\n            emailOrUsername: r,\n            password: o,\n            redirect: i,\n            handleUpstreamResponse: s,\n            handleMfaRequired: c,\n            handlePkceRequired: u,\n            handleTokens: h,\n            handleRedirect: l,\n            options: f\n          }) {\n            try {\n              return Promise.resolve(function (a, m) {\n                try {\n                  var p = function () {\n                    const a = {\n                      tenantId: t.tenantId,\n                      emailOrUsername: e || n || r,\n                      password: o\n                    };\n                    return f && f.noResetEmail && (a.options = {\n                      noResetEmail: !0\n                    }), Promise.resolve(d(\"/auth/password/migrate\", a, {\n                      headers: k(),\n                      params: T()\n                    })).then(function ({\n                      data: e\n                    }) {\n                      return b({\n                        data: e,\n                        redirect: i,\n                        handleUpstreamResponse: s,\n                        handleMfaRequired: c,\n                        handlePkceRequired: u,\n                        handleTokens: h,\n                        handleRedirect: l\n                      });\n                    });\n                  }();\n                } catch (e) {\n                  return m(e);\n                }\n                return p && p.then ? p.then(void 0, m) : p;\n              }(0, function (e) {\n                a(e);\n              }));\n            } catch (e) {\n              return Promise.reject(e);\n            }\n          }({\n            email: o,\n            username: i,\n            emailOrUsername: s,\n            password: l,\n            redirect: R,\n            handleUpstreamResponse: g,\n            handleMfaRequired: U,\n            handlePkceRequired: q,\n            handleTokens: $,\n            handleRedirect: E,\n            options: j\n          }));\n        case \"passwordless\":\n          return Promise.resolve(D({\n            email: o\n          }));\n        case \"link\":\n          return Promise.resolve(function ({\n            token: e,\n            uuid: n,\n            redirect: r,\n            handleUpstreamResponse: o,\n            handleMfaRequired: i,\n            handlePkceRequired: s,\n            handleTokens: c,\n            handleRedirect: d\n          } = {}) {\n            try {\n              return Promise.resolve(B(function () {\n                if (e = e || I(\"token\"), n = n || I(\"uuid\"), e && n) return Promise.resolve(u(\"/auth/link\", {\n                  token: e,\n                  uuid: n,\n                  tenantId: t.tenantId\n                }, {\n                  headers: k(),\n                  params: T()\n                })).then(function ({\n                  data: e\n                }) {\n                  return b({\n                    data: e,\n                    redirect: r,\n                    handleUpstreamResponse: o,\n                    handleMfaRequired: i,\n                    handlePkceRequired: s,\n                    handleTokens: c,\n                    handleRedirect: d\n                  });\n                });\n              }, function (e) {\n                a(e);\n              }));\n            } catch (e) {\n              return Promise.reject(e);\n            }\n          }({\n            token: f,\n            uuid: m,\n            redirect: R,\n            handleUpstreamResponse: g,\n            handleMfaRequired: U,\n            handlePkceRequired: q,\n            handleTokens: $,\n            handleRedirect: E\n          }));\n        case \"totp\":\n          return Promise.resolve(function ({\n            totpCode: e,\n            backupCode: n,\n            userId: r,\n            userUuid: o,\n            emailOrUsername: i,\n            email: s,\n            username: c,\n            phoneNumber: u,\n            redirect: h,\n            handleUpstreamResponse: l,\n            handleMfaRequired: f,\n            handlePkceRequired: m,\n            handleTokens: p,\n            handleRedirect: w\n          } = {}) {\n            try {\n              return Promise.resolve(V(function () {\n                return Promise.resolve(d(\"/auth/totp\", {\n                  totpCode: e,\n                  backupCode: n,\n                  userId: r,\n                  userUuid: o,\n                  emailOrUsername: i,\n                  email: s,\n                  username: c,\n                  phoneNumber: u,\n                  tenantId: t.tenantId\n                }, {\n                  headers: k(),\n                  params: T()\n                })).then(function ({\n                  data: e\n                }) {\n                  return b({\n                    data: e,\n                    redirect: h,\n                    handleUpstreamResponse: l,\n                    handleMfaRequired: f,\n                    handlePkceRequired: m,\n                    handleTokens: p,\n                    handleRedirect: w\n                  });\n                });\n              }, function (e) {\n                a(e);\n              }));\n            } catch (e) {\n              return Promise.reject(e);\n            }\n          }({\n            totpCode: p,\n            backupCode: w,\n            userId: n,\n            userUuid: r,\n            emailOrUsername: s,\n            email: o,\n            username: i,\n            phoneNumber: c,\n            redirect: R,\n            handleUpstreamResponse: g,\n            handleMfaRequired: U,\n            handlePkceRequired: q,\n            handleTokens: $,\n            handleRedirect: E\n          }));\n        case \"verificationCode\":\n          return Promise.resolve(function ({\n            channel: e,\n            verificationCode: n,\n            email: r,\n            phoneNumber: o,\n            redirect: i,\n            handleUpstreamResponse: s,\n            handleMfaRequired: c,\n            handlePkceRequired: d,\n            handleTokens: h,\n            handleRedirect: l\n          } = {}) {\n            try {\n              return Promise.resolve(J(function () {\n                return W({\n                  channel: e,\n                  phoneNumber: o,\n                  email: r\n                }), Promise.resolve(u(\"/auth/code\", {\n                  channel: e,\n                  verificationCode: n,\n                  email: r,\n                  phoneNumber: o,\n                  tenantId: t.tenantId\n                }, {\n                  headers: k(),\n                  params: T()\n                })).then(function ({\n                  data: e\n                }) {\n                  return b({\n                    data: e,\n                    redirect: i,\n                    handleUpstreamResponse: s,\n                    handleMfaRequired: c,\n                    handlePkceRequired: d,\n                    handleTokens: h,\n                    handleRedirect: l\n                  });\n                });\n              }, function (e) {\n                a(e);\n              }));\n            } catch (e) {\n              return Promise.reject(e);\n            }\n          }({\n            channel: v,\n            email: o,\n            phoneNumber: c,\n            verificationCode: P,\n            redirect: R,\n            handleUpstreamResponse: g,\n            handleMfaRequired: U,\n            handlePkceRequired: q,\n            handleTokens: $,\n            handleRedirect: E\n          }));\n        case \"saml\":\n          return Promise.resolve(function () {\n            try {\n              return Promise.resolve(function (e, n) {\n                try {\n                  var r = t.tokens.accessToken ? Promise.resolve(h(\"/auth/saml/idp/token\", {\n                    headers: {\n                      authorization: `Bearer ${t.tokens.accessToken}`\n                    }\n                  })).then(function ({\n                    data: e\n                  }) {\n                    window.location.assign(`${t.baseUrl}auth/saml/idp/login?tenant_id=${t.tenantId}&token=${e.token}&uuid=${t.user.userUuid}`);\n                  }) : console.warn(\"Cannot complete SAML login without access token\");\n                } catch (e) {\n                  return n(e);\n                }\n                return r && r.then ? r.then(void 0, n) : r;\n              }(0, function (e) {\n                a(e);\n              }));\n            } catch (e) {\n              return Promise.reject(e);\n            }\n          }());\n        default:\n          throw new Error('Userfront.login called with invalid \"method\" property.');\n      }\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  },\n  resetPassword: A,\n  updatePassword: x,\n  sendLoginLink: function (e) {\n    try {\n      return Promise.resolve(B(function () {\n        return Promise.resolve(d(\"/auth/link\", {\n          email: e,\n          tenantId: t.tenantId\n        })).then(function ({\n          data: e\n        }) {\n          return e;\n        });\n      }, function (e) {\n        a(e);\n      }));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  },\n  sendResetLink: function (e) {\n    try {\n      return Promise.resolve(O(function () {\n        return Promise.resolve(d(\"/auth/reset/link\", {\n          email: e,\n          tenantId: t.tenantId\n        })).then(function ({\n          data: e\n        }) {\n          return e;\n        });\n      }, function (e) {\n        a(e);\n      }));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  },\n  sendVerificationCode: K,\n  signup: function ({\n    method: e,\n    email: n,\n    username: r,\n    phoneNumber: o,\n    name: i,\n    data: s,\n    password: c,\n    channel: u,\n    redirect: h,\n    handleUpstreamResponse: l,\n    handleMfaRequired: f,\n    handlePkceRequired: m,\n    handleTokens: p,\n    handleRedirect: w\n  } = {}) {\n    try {\n      if (y(), !e) throw new Error('Userfront.signup called without \"method\" property.');\n      switch (e) {\n        case \"apple\":\n        case \"azure\":\n        case \"facebook\":\n        case \"github\":\n        case \"google\":\n        case \"linkedin\":\n        case \"okta\":\n          return Promise.resolve(L({\n            provider: e,\n            redirect: h\n          }));\n        case \"password\":\n          return Promise.resolve(function ({\n            username: e,\n            name: n,\n            email: r,\n            password: o,\n            userData: i,\n            redirect: s,\n            handleUpstreamResponse: c,\n            handleMfaRequired: u,\n            handlePkceRequired: h,\n            handleTokens: l,\n            handleRedirect: f\n          } = {}) {\n            try {\n              return Promise.resolve(O(function () {\n                return Promise.resolve(d(\"/auth/create\", {\n                  tenantId: t.tenantId,\n                  username: e,\n                  name: n,\n                  email: r,\n                  password: o,\n                  data: i\n                }, {\n                  headers: k(),\n                  params: T()\n                })).then(function ({\n                  data: e\n                }) {\n                  return b({\n                    data: e,\n                    redirect: s,\n                    handleUpstreamResponse: c,\n                    handleMfaRequired: u,\n                    handlePkceRequired: h,\n                    handleTokens: l,\n                    handleRedirect: f\n                  });\n                });\n              }, function (e) {\n                a(e);\n              }));\n            } catch (e) {\n              return Promise.reject(e);\n            }\n          }({\n            username: r,\n            name: i,\n            email: n,\n            password: c,\n            userData: s,\n            redirect: h,\n            handleUpstreamResponse: l,\n            handleMfaRequired: f,\n            handlePkceRequired: m,\n            handleTokens: p,\n            handleRedirect: w\n          }));\n        case \"passwordless\":\n          return Promise.resolve(D({\n            email: n,\n            name: i,\n            username: r,\n            userData: s\n          }));\n        case \"verificationCode\":\n          return Promise.resolve(K({\n            channel: u,\n            email: n,\n            phoneNumber: o,\n            name: i,\n            username: r,\n            data: s\n          }));\n        default:\n          throw new Error('Userfront.signup called with invalid \"method\" property.');\n      }\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  },\n  store: t,\n  tokens: F,\n  accessToken: function () {\n    return t.tokens.accessToken = n.get(t.tokens.accessTokenName), t.tokens.accessToken;\n  },\n  idToken: function () {\n    return t.tokens.idToken = n.get(t.tokens.idTokenName), t.tokens.idToken;\n  },\n  getSession: v,\n  redirectIfLoggedIn: function ({\n    redirect: e\n  } = {}) {\n    try {\n      return Promise.resolve(v()).then(function ({\n        isLoggedIn: n\n      }) {\n        if (!n) return m();\n        if (R.usePkce) return;\n        if (e) return q(e);\n        if (I(\"redirect\")) return q(I(\"redirect\"));\n        const r = function (e, n) {\n          try {\n            var r = Promise.resolve(h(\"/self\", {\n              headers: {\n                authorization: `Bearer ${t.tokens.accessToken}`\n              }\n            })).then(function ({\n              data: e\n            }) {\n              e.tenant && e.tenant.loginRedirectPath && q(e.tenant.loginRedirectPath);\n            });\n          } catch (e) {\n            return n();\n          }\n          return r && r.then ? r.then(void 0, n) : r;\n        }(0, function () {\n          m();\n        });\n        return r && r.then ? r.then(function () {}) : void 0;\n      });\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  },\n  redirectIfLoggedOut: function ({\n    redirect: e\n  } = {}) {\n    try {\n      return Promise.resolve(v()).then(function ({\n        isLoggedIn: n\n      }) {\n        if (!n) return m(), e ? q(e) : I(\"redirect\") ? q(I(\"redirect\")) : void 0;\n      });\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  },\n  user: s\n};\nexport { te as default };","map":{"version":3,"names":["t","user","tokens","mode","r","e","n","split","replace","decodeURIComponent","window","atob","map","charCodeAt","toString","slice","join","JSON","parse","console","error","o","Date","exp","a","Error","response","data","message","i","s","c","u","baseUrl","Promise","resolve","put","reject","d","post","h","get","l","tenantId","secure","sameSite","set","f","location","pathname","hostname","domain","path","remove","m","accessTokenName","idTokenName","refreshTokenName","accessToken","idToken","refreshToken","p","$","firstFactorToken","k","authorization","w","secondFactors","v","getSession","P","then","isLoggedIn","needsSecondFactor","firstFactors","resetMfaState","getIsLoggedIn","_","M","R","codeChallenge","usePkce","g","localStorage","removeItem","y","I","now","setItem","getItem","parseInt","T","code_challenge","href","indexOf","U","defaultHandleRedirect","q","redirectTo","document","createElement","assign","hash","search","b","redirect","handleUpstreamResponse","handleMfaRequired","handlePkceRequired","handleTokens","handleRedirect","hasOwnProperty","authorizationCode","warn","URL","searchParams","C","isMfaRequired","authentication","upstreamResponse","E","access","value","cookieOptions","id","refresh","N","j","headers","status","F","O","S","updatePasswordWithJwt","password","existingPassword","Authorization","z","updatePasswordWithLink","uuid","token","x","updatePassword","method","A","L","provider","origin","encodeURIComponent","B","D","sendPasswordlessLink","email","name","username","userData","options","J","W","channel","phoneNumber","K","V","G","H","Q","setMode","X","reason","Z","Array","isArray","Y","match","protocol","update","Object","keys","length","hasRole","roles","getTotp","ee","ne","te","addInitCallback","push","init","endsWith","defaults","common","forEach","registerUrlChangedEventListener","history","pushState","apply","arguments","dispatchEvent","Event","replaceState","addEventListener","logout","userUuid","login","userId","emailOrUsername","totpCode","backupCode","verificationCode","noResetEmail","params","resetPassword","sendLoginLink","sendResetLink","sendVerificationCode","signup","store","redirectIfLoggedIn","tenant","loginRedirectPath","redirectIfLoggedOut","default"],"sources":["E:\\Course Curator\\portfolio-app-react\\client\\node_modules\\@userfront\\core\\src\\store.js","E:\\Course Curator\\portfolio-app-react\\client\\node_modules\\@userfront\\core\\src\\utils.js","E:\\Course Curator\\portfolio-app-react\\client\\node_modules\\@userfront\\core\\src\\user.js","E:\\Course Curator\\portfolio-app-react\\client\\node_modules\\@userfront\\core\\src\\api.js","E:\\Course Curator\\portfolio-app-react\\client\\node_modules\\@userfront\\core\\src\\cookies.js","E:\\Course Curator\\portfolio-app-react\\client\\node_modules\\@userfront\\core\\src\\tokens.js","E:\\Course Curator\\portfolio-app-react\\client\\node_modules\\@userfront\\core\\src\\mfa.js","E:\\Course Curator\\portfolio-app-react\\client\\node_modules\\@userfront\\core\\src\\session.js","E:\\Course Curator\\portfolio-app-react\\client\\node_modules\\@userfront\\core\\src\\pkce.js","E:\\Course Curator\\portfolio-app-react\\client\\node_modules\\@userfront\\core\\src\\url.js","E:\\Course Curator\\portfolio-app-react\\client\\node_modules\\@userfront\\core\\src\\authentication.js","E:\\Course Curator\\portfolio-app-react\\client\\node_modules\\@userfront\\core\\src\\refresh.js","E:\\Course Curator\\portfolio-app-react\\client\\node_modules\\@userfront\\core\\src\\password.js","E:\\Course Curator\\portfolio-app-react\\client\\node_modules\\@userfront\\core\\src\\sso.js","E:\\Course Curator\\portfolio-app-react\\client\\node_modules\\@userfront\\core\\src\\link.js","E:\\Course Curator\\portfolio-app-react\\client\\node_modules\\@userfront\\core\\src\\verificationCode.js","E:\\Course Curator\\portfolio-app-react\\client\\node_modules\\@userfront\\core\\src\\totp.js","E:\\Course Curator\\portfolio-app-react\\client\\node_modules\\@userfront\\core\\src\\logout.js","E:\\Course Curator\\portfolio-app-react\\client\\node_modules\\@userfront\\core\\src\\constants.js","E:\\Course Curator\\portfolio-app-react\\client\\node_modules\\@userfront\\core\\src\\mode.js","E:\\Course Curator\\portfolio-app-react\\client\\node_modules\\@userfront\\core\\src\\user.methods.js","E:\\Course Curator\\portfolio-app-react\\client\\node_modules\\@userfront\\core\\src\\index.js","E:\\Course Curator\\portfolio-app-react\\client\\node_modules\\@userfront\\core\\src\\login.js","E:\\Course Curator\\portfolio-app-react\\client\\node_modules\\@userfront\\core\\src\\password.migrate.js","E:\\Course Curator\\portfolio-app-react\\client\\node_modules\\@userfront\\core\\src\\saml.js","E:\\Course Curator\\portfolio-app-react\\client\\node_modules\\@userfront\\core\\src\\signup.js"],"sourcesContent":["export const store = {\n  user: {},\n  tokens: {},\n  mode: \"live\",\n};\n","/**\n * This file is for zero-dependency utilities that can\n * be imported by any other file. Don't add any imports\n * to this file other than constants\n */\n\n/**\n * Get the unverified base64 decoded payload of a JWT\n *\n * @param {String} token - JSON Web Token\n * @returns {Object}\n */\nexport function getJwtPayload(token) {\n  try {\n    // Split token into constituent parts\n    const base64Url = token.split('.')[1];\n    // Convert from base64url to base64 encoding\n    const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');\n    \n    // To correctly decode a UTF-8 string without misinterpreting non-ASCII characters:\n    // 1. Decode the base64 to a UTF-16 string that may contain misinterpreted chars (window.atob)\n    //    -> DOMStrings are natively UTF-16LE, while JWTs are UTF-8\n    // 2. Convert the string to percent encoding (map each char to %HH where HH = hex value of byte)\n    //    (the '00' + ... + .slice(-2) bit ensures a single char is encoded correctly,\n    //     not strictly necessary here but included for correctness)\n    // 3. Interpret the percent-encoded string as a URI component, which is UTF-8 by definition (decodeURIComponent)\n    //    -> now non-ASCII characters \n    //  \n    const jsonPayload = decodeURIComponent(window.atob(base64).split('').map(c => \n      '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2)\n    ).join(''));\n\n    return JSON.parse(jsonPayload);\n  } catch (error) {\n    console.error(\"Problem decoding JWT payload\", error);\n  }\n}\n\n/*\n  Worked example of decoding above:\n  A JWT payload {\"foo\":\"bår\"} is base64url encoded as eyJmb28iOiJiw6VyIn0\n  1. base64url to base64: eyJmb28iOiJiw6VyIn0\n    = eyJmb28iOiJiw6VyIn0\n    (no change in this case)\n  2. base64 to DOMString: atob(eyJmb28iOiJiw6VyIn0)\n    = {\"foo\":\"bÃ¥r\"}\n    ->  \"å\" in UTF-8 encoding = 0xC3 0xA5\n        0xC3 0xA5 as UTF-16LE = Ã¥\n  3. DOMString to percent-encoding\n    = %7b%22%66%6f%6f%22%3a%22%62 %c3%a5 %72%22%7d\n    -> Ã¥ was encoded as %c3%a5 \n  4. Percent-encoded UTF-8 to DOMString\n    = {\"foo\":\"bår\"}\n    ->  URIs are always UTF-8, so decodeURIComponent knows to interpret the percent-encoded\n        string as UTF-8.\n        (As before, DOMStrings are UTF-16LE, so internally \"å\" is encoded as 0xE5 per UTF-16.)\n  Note: UTF-8 and UTF-16 are equivalent in the ASCII range 0x00 - 0x7f, so atob(base64) is OK\n  if it's known that the string uses only those characters.\n*/\n\n/**\n * Client-side check:\n * Determine whether the given JWT is present and unexpired\n *\n * @param {String} token JSON Web Token\n * @returns {Boolean}\n */\nexport function isJwtLocallyValid(token) {\n  try {\n    // Must be present\n    if (!token) {\n      return false;\n    }\n\n    // Must not be expired\n    const payload = getJwtPayload(token);\n    return new Date(payload.exp * 1000) > new Date();\n  } catch (error) {\n    return false;\n  }\n}\n\nexport function throwFormattedError(error) {\n  if (!error) return;\n  if (typeof error === \"string\") throw new Error(error);\n  if (error?.response?.data?.message) {\n    throw new Error(error.response.data.message);\n  }\n  throw error;\n}\n\nexport function isBrowser() {\n  return typeof window !== \"undefined\";\n}","import { store } from \"./store.js\";\nimport { getJwtPayload } from \"./utils.js\";\n\n/**\n * Define the store.user object based on the ID token\n */\nexport function setUser() {\n  if (!store.tokens.idToken) {\n    return console.warn(\"Cannot define user: missing ID token\");\n  }\n\n  store.user = store.user || {};\n  const idTokenPayload = getJwtPayload(store.tokens.idToken);\n\n  // Set basic user information properties from ID token\n  const propsToDefine = [\n    \"email\",\n    \"phoneNumber\",\n    \"username\",\n    \"name\",\n    \"image\",\n    \"data\",\n    \"createdAt\",\n    \"updatedAt\",\n    \"mode\",\n    \"userId\",\n    \"userUuid\",\n    \"tenantId\",\n    \"isEmailConfirmed\",\n    \"isPhoneNumberConfirmed\",\n    \"confirmedEmailAt\",\n    \"confirmedPhoneNumberAt\",\n    \"isMfaRequired\",\n    \"isConfirmed\", // Deprecated\n  ];\n  for (const prop of propsToDefine) {\n    if (prop === \"update\") return;\n    store.user[prop] = idTokenPayload[prop];\n  }\n}\n\n/**\n * Remove all user information\n */\nexport function unsetUser() {\n  for (const attr in store.user) {\n    if (typeof store.user[attr] !== \"function\") {\n      delete store.user[attr];\n    }\n  }\n}\n\n/**\n * Export the store.user object with the update method added\n */\nexport const user = store.user;\n","import axios from \"axios\";\nimport { store } from \"./store.js\";\n\n// Replace multiple slashes // with single slash / (except in the protocol)\nfunction reduceSlashes(str) {\n  return str.replace(/([^:]\\/)\\/+/g, \"$1\");\n}\n\n/**\n * Perform a GET request\n * @param {String} path\n * @param {Object} options\n * @returns {Object} response body\n */\nexport async function get(path, options) {\n  const url = reduceSlashes(`${store.baseUrl}${path}`);\n  return axios.get(url, options);\n}\n\n/**\n * Perform a POST request\n * @param {String} path\n * @param {Object} payload\n * @param {Object} options\n * @returns {Object} response body\n */\nexport async function post(path, payload, options) {\n  const url = reduceSlashes(`${store.baseUrl}${path}`);\n  return axios.post(url, payload, options);\n}\n\n/**\n * Perform a PUT request\n * @param {String} path\n * @param {Object} payload\n * @param {Object} options\n * @returns {Object} response body\n */\nexport async function put(path, payload, options) {\n  const url = reduceSlashes(`${store.baseUrl}${path}`);\n  return axios.put(url, payload, options);\n}\n\nexport default {\n  get,\n  post,\n  put,\n};\n","import Cookies from \"js-cookie\";\nimport { store } from \"./store.js\";\nimport { unsetTokens } from \"./tokens.js\";\n\n/**\n * Set a cookie value based on the given options.\n * @param {String} value\n * @param {Object} options\n * @param {String} type\n */\nexport function setCookie(value, options, type) {\n  const cookieName = `${type}.${store.tenantId}`;\n  options = options || {\n    secure: store.mode === \"live\",\n    sameSite: \"Lax\",\n  };\n  if (type === \"refresh\") {\n    options.sameSite = \"Strict\";\n  }\n  Cookies.set(cookieName, value, options);\n}\n\n/**\n * Remove a cookie by name, regardless of its cookie setting(s).\n * @param {String} name\n */\nfunction removeCookie(name) {\n  // Define all possible path and domain combinations\n  let paths, domains;\n  try {\n    const path = window.location.pathname;\n    const hostname = window.location.hostname;\n    const hostnameParts = hostname.split(\".\");\n    const primaryDomain = hostnameParts.slice(-2).join(\".\");\n    paths = [undefined, path, \"/\"];\n    domains = [\n      undefined,\n      hostname,\n      `.${hostname}`,\n      primaryDomain,\n      `.${primaryDomain}`,\n    ];\n  } catch (err) {\n    paths = [undefined, \"/\"];\n    domains = [undefined];\n  }\n\n  // Iterate over paths and domains, and remove cookies if present\n  paths.map((path) => {\n    domains.map((domain) => {\n      const options = {};\n      if (domain) options.domain = domain;\n      if (path) options.path = path;\n      Cookies.remove(name, options);\n    });\n  });\n}\n\n/**\n * Remove all auth cookies (access, id, refresh).\n */\nexport function removeAllCookies() {\n  removeCookie(store.tokens.accessTokenName);\n  removeCookie(store.tokens.idTokenName);\n  removeCookie(store.tokens.refreshTokenName);\n  unsetTokens();\n}\n","import Cookies from \"js-cookie\";\nimport { store } from \"./store.js\";\nimport { setUser, unsetUser } from \"./user.js\";\nimport { refresh } from \"./refresh.js\";\nimport { isJwtLocallyValid } from \"./utils.js\";\nimport { setCookiesAndTokens } from \"./authentication.js\";\nimport { exchange } from \"./refresh.js\";\n\nstore.tokens = store.tokens || {};\nstore.tokens.refresh = refresh;\n\nexport function setTokenNames() {\n  store.tokens = store.tokens || {};\n  store.tokens.accessTokenName = `access.${store.tenantId}`;\n  store.tokens.idTokenName = `id.${store.tenantId}`;\n  store.tokens.refreshTokenName = `refresh.${store.tenantId}`;\n}\n\n/**\n * Set and then return the access token\n */\nexport function accessToken() {\n  store.tokens.accessToken = Cookies.get(store.tokens.accessTokenName);\n  return store.tokens.accessToken;\n}\n\n/**\n * Set and then return the ID token\n */\nexport function idToken() {\n  store.tokens.idToken = Cookies.get(store.tokens.idTokenName);\n  return store.tokens.idToken;\n}\n\n/**\n * Define the store token values from the cookie values.\n */\nexport function setTokensFromCookies() {\n  const tokenNames = [\"access\", \"id\", \"refresh\"];\n  tokenNames.map((tokenName) => {\n    try {\n      const token = Cookies.get(store.tokens[`${tokenName}TokenName`]);\n      store.tokens[`${tokenName}Token`] = token;\n\n      // Set the user object whenever the ID token is set\n      if (tokenName === \"id\" && token) {\n        setUser();\n      }\n    } catch (error) {\n      console.warn(`Problem setting ${tokenName} token.`);\n    }\n  });\n}\n\n/**\n * Set the store token values to undefined\n */\nexport function unsetTokens() {\n  store.tokens.accessToken = undefined;\n  store.tokens.idToken = undefined;\n  store.tokens.refreshToken = undefined;\n  unsetUser();\n}\n\n/**\n * Client-side check:\n * Determine whether the access token is present and unexpired\n * @returns {Boolean}\n */\nexport function isAccessTokenLocallyValid() {\n  return isJwtLocallyValid(store.tokens.accessToken);\n}\n\n/**\n * Client-side check:\n * Determine whether the refresh token is present and unexpired\n * @returns {Boolean}\n */\nexport function isRefreshTokenLocallyValid() {\n  return isJwtLocallyValid(store.tokens.refreshToken);\n}\n\n/**\n * Set the cookies and store.tokens based on a tokens object\n * @property {Object} tokens An object containing JWT access, refresh, and ID tokens\n * @property {Object} data The response object from the API\n * @returns\n */\nexport async function defaultHandleTokens(tokens, data) {\n  setCookiesAndTokens(tokens);\n  await exchange(data);\n}\n\n/**\n * Export the store.tokens object\n */\nexport const tokens = store.tokens;\n\n// NOTE Commenting this out 6/11/21 because the packages it relies on (jsonwebtoken & jwks-rsa)\n// both cause a lot of bloat. If we want to verify tokens, this is a nice way to do it, but\n// we need to find libraries designed for the browser instead of node.\n/**\n * Verify the provided token\n * @param {String} token\n * @returns {Promise<void>} The provided token has been verified if `verifyToken` resolves without error\n */\n// export async function verifyToken(token) {\n//   if (!token) throw new Error(\"Missing token\");\n\n//   let publicKey;\n//   try {\n//     const decodedToken = jwt.decode(token, { complete: true });\n//     if (!decodedToken.header || !decodedToken.header.kid) {\n//       throw new Error(\"Token kid not defined\");\n//     }\n\n//     const client = new JwksClient({\n//       jwksUri: `${apiUrl}tenants/${store.tenantId}/jwks/${store.mode}`,\n//       requestHeaders: { origin: window.location.origin },\n//     });\n\n//     const key = await client.getSigningKey(decodedToken.header.kid);\n//     publicKey = key.getPublicKey();\n//   } catch (error) {\n//     throw error;\n//   }\n\n//   if (!publicKey) {\n//     throw new Error(\"Public key not found\");\n//   }\n\n//   try {\n//     jwt.verify(token, publicKey);\n//   } catch (error) {\n//     throw new Error(\"Token verification failed\");\n//   }\n\n//   return Promise.resolve();\n// }\n","import { store } from \"./store.js\";\nimport { authenticationData } from \"./authentication.js\";\n\n/**\n * Set authenticationData.firstFactors from the authentication object\n * @param {Object} authentication\n * {\n *   firstFactors,\n *   secondFactors\n * }\n * @returns\n */\nexport function setFirstFactors(authentication) {\n  // If we're not initialized, there are no first factors.\n  if (!store.tenantId) {\n    console.warn(\n      \"setFirstFactors: tried to set factors without a tenantId set.\"\n    );\n    return;\n  }\n  // If we're passed an invalid argument, keep the authentication data as is.\n  if (\n    !authentication ||\n    typeof authentication !== \"object\" ||\n    !Array.isArray(authentication.firstFactors)\n  ) {\n    console.warn(\"setFirstFactors: invalid factors passed.\");\n    return;\n  }\n  authenticationData.firstFactors = authentication.firstFactors;\n}\n\n/**\n * Check if MFA is required for the ongoing signup or login flow.\n * @returns {Boolean} true if MFA is currently required\n */\nexport function isFirstFactorTokenPresent() {\n  return !!authenticationData.firstFactorToken;\n}\n\n/**\n * Update the MFA service state given a response to a signup or login call.\n * Adds secondFactors and firstFactorToken if it is a MFA Required response,\n * removes them if it is a successful signup or login,\n * leaves the service unchanged otherwise.\n * @param {Object} data\n */\nexport function defaultHandleMfaRequired(firstFactorToken, data) {\n  if (!data.isMfaRequired) {\n    // If we've logged in or signed up successfully,\n    // clear the MFA service state.\n    if (data.message === \"OK\") {\n      clearMfa();\n    }\n    return;\n  }\n  authenticationData.firstFactorToken = firstFactorToken;\n  authenticationData.secondFactors = data.authentication.secondFactors;\n}\n\n/**\n * If MFA is required, returns a headers object with authorization set to the firstFactorToken.\n * Otherwise, returns an empty object.\n * @returns {Object} a headers object with MFA authorization header set, or empty if MFA is not required\n */\nexport function getMfaHeaders() {\n  if (authenticationData.firstFactorToken) {\n    return {\n      authorization: `Bearer ${authenticationData.firstFactorToken}`,\n    };\n  }\n  return {};\n}\n\n/**\n * Clears the current transient state of the MFA service,\n * leaving the tenant's persistent state in place.\n */\nexport function clearMfa() {\n  authenticationData.secondFactors = [];\n  authenticationData.firstFactorToken = null;\n}\n\n/**\n * Fully resets the MFA service, including the tenant's persistent state,\n * to it uninitialized state.\n */\nexport function resetMfa() {\n  clearMfa();\n  authenticationData.firstFactors = [];\n}\n","import {\n  isAccessTokenLocallyValid,\n  isRefreshTokenLocallyValid,\n} from \"./tokens.js\";\nimport { authenticationData } from \"./authentication.js\";\nimport { isFirstFactorTokenPresent, clearMfa } from \"./mfa.js\";\nimport { refresh } from \"./refresh.js\";\n\n/**\n * Determine whether a user is logged in by checking their\n * JWT access token and, if invalid, refreshing it and checking\n * again.\n * @returns {Promise<Boolean>}\n */\nasync function getIsLoggedIn() {\n  try {\n    // If the access token is locally valid, return true\n    if (isAccessTokenLocallyValid()) {\n      return true;\n    }\n\n    // If the refresh token is locally invalid, return false\n    if (!isRefreshTokenLocallyValid()) {\n      return false;\n    }\n\n    // Attempt to refresh the access token\n    await refresh();\n\n    // The access token should now be valid\n    return isAccessTokenLocallyValid();\n  } catch (error) {\n    return false;\n  }\n}\n\n/**\n * Return detailed information about the current session.\n * @returns {Promise<Object>}\n */\nexport async function getSession() {\n  const isLoggedIn = await getIsLoggedIn();\n  return {\n    isLoggedIn,\n    needsSecondFactor: isFirstFactorTokenPresent(),\n    firstFactors: authenticationData.firstFactors,\n    secondFactors: authenticationData.secondFactors,\n    resetMfaState: clearMfa,\n  };\n}\n","import { getQueryAttr } from \"./url.js\";\nimport { isBrowser } from \"./utils.js\";\n\nexport const store = {\n  codeChallenge: \"\",\n  get usePkce() {\n    return !!store.codeChallenge;\n  },\n};\n\n/**\n * Reads an unexpired challenge code from local storage\n * @returns {string?} the challenge code, if an unexpired one is in local storage\n */\nexport function readPkceDataFromLocalStorage() {\n  if (!isBrowser()) {\n    return;\n  }\n  const codeChallenge = window.localStorage.getItem(\"uf_pkce_code_challenge\");\n  if (codeChallenge) {\n    const expiresAt = window.localStorage.getItem(\n      \"uf_pkce_code_challenge_expiresAt\"\n    );\n    if (expiresAt && parseInt(expiresAt, 10) > Date.now()) {\n      return codeChallenge;\n    }\n  }\n}\n\n/**\n * Write a challenge code to local storage, expiring in 5 minutes\n * @param {string} codeChallenge\n * @returns\n */\nexport function writePkceDataToLocalStorage(codeChallenge) {\n  if (!isBrowser()) {\n    return;\n  }\n  if (!codeChallenge) {\n    return clearPkceDataFromLocalStorage();\n  }\n  store.codeChallenge = codeChallenge;\n  const expiresAt = Date.now() + 1000 * 60 * 5; // 5 minutes from now\n  try {\n    window.localStorage.setItem(\"uf_pkce_code_challenge\", codeChallenge);\n    window.localStorage.setItem(\"uf_pkce_code_challenge_expiresAt\", expiresAt);\n  } catch (err) {\n    // Suppress exception from full local storage\n  }\n}\n\n/**\n * Clear the challenge code and expiration from local storage\n */\nexport function clearPkceDataFromLocalStorage() {\n  if (!isBrowser()) {\n    return;\n  }\n  window.localStorage.removeItem(\"uf_pkce_code_challenge\");\n  window.localStorage.removeItem(\"uf_pkce_code_challenge_expiresAt\");\n}\n\n/**\n * Set up the PKCE service: look for a PKCE challenge code in\n * query params or local storage. If both are present, the query\n * param is preferred.\n * @returns {Boolean} true if we should use PKCE in our auth requests\n */\nexport function setupPkce() {\n  if (!isBrowser()) {\n    return;\n  }\n  const codeChallengeFromQueryParams = getQueryAttr(\"code_challenge\");\n  if (codeChallengeFromQueryParams) {\n    store.codeChallenge = codeChallengeFromQueryParams;\n    writePkceDataToLocalStorage(codeChallengeFromQueryParams);\n    return true;\n  }\n  const codeChallengeFromLocalStorage = readPkceDataFromLocalStorage();\n  if (codeChallengeFromLocalStorage) {\n    store.codeChallenge = codeChallengeFromLocalStorage;\n    return true;\n  }\n  clearPkceDataFromLocalStorage();\n  return false;\n}\n\n/**\n * Get (possibly empty) PKCE query params to attach to an auth request\n * @returns {object} an object to be used for an Axios request's params field\n */\nexport function getPkceRequestQueryParams() {\n  if (!store.usePkce) {\n    return {};\n  }\n  return { code_challenge: store.codeChallenge };\n}\n\n/**\n * Redirect to url with PKCE query params (authorization_code) set. Does not redirect\n * if url or authorizationCode are falsy.\n *\n * @param {string} url full URL to redirect to (may be a deep link for a mobile app)\n * @param {string} authorizationCode the authorization code received from the server\n * @returns\n */\nexport function defaultHandlePkceRequired(authorizationCode, url, data) {\n  if (!url || !authorizationCode) {\n    return;\n  }\n  if (!store.usePkce) {\n    console.warn(\n      \"Redirecting with a PKCE authorization code, but no PKCE challenge code is present in the client. This is unexpected.\"\n    );\n  }\n  const _url = new URL(url);\n  _url.searchParams.set(\"authorization_code\", authorizationCode);\n  clearPkceDataFromLocalStorage();\n  window.location.assign(_url.href);\n}\n","import { get } from \"./api.js\";\nimport { store } from \"./store.js\";\nimport { removeAllCookies } from \"./cookies.js\";\nimport { getSession } from \"./session.js\";\nimport { store as pkceStore } from \"./pkce.js\";\n\n/**\n * Get the value of a query attribute, e.g. ?attr=value\n * @param {String} attrName\n */\nexport function getQueryAttr(attrName) {\n  if (\n    typeof window !== \"object\" ||\n    typeof window.location !== \"object\" ||\n    !window.location.href ||\n    window.location.href.indexOf(`${attrName}=`) < 0\n  ) {\n    return;\n  }\n  return decodeURIComponent(\n    window.location.href.split(`${attrName}=`)[1].split(\"&\")[0]\n  );\n}\n\n/**\n * Redirect the browser based on explicit redirect input path, or the API response\n * @property {String|Boolean} redirect A path to redirect to, or false to not redirect\n * @property {Object} data The response object from the API\n * @returns\n */\nexport const defaultHandleRedirect = (redirect, data) => {\n  if (redirect === false) return;\n  // If redirect is the boolean true, redirect to the default redirect path, not to \"/true\"\n  if (redirect === true) {\n    const path = getQueryAttr(\"redirect\") || data.redirectTo || \"/\";\n    redirectToPath(path);\n    return;\n  }\n  const path = redirect || getQueryAttr(\"redirect\") || data.redirectTo || \"/\";\n  redirectToPath(path);\n};\n\n/**\n * If the access token is valid, redirect the browser to the\n * tenant's After-login path.\n */\nexport async function redirectIfLoggedIn({ redirect } = {}) {\n  const { isLoggedIn } = await getSession();\n  if (!isLoggedIn) {\n    return removeAllCookies();\n  }\n\n  // TODO see #130: can handle this more elegantly once we have an exchange tokens -> authorizationCode\n  // endpoint on the server.\n  // If this is a PKCE auth session, don't redirect with this function ever.\n  // The only way to get an authorizationCode currently is to go through an auth flow.\n  // The PKCE module handles redirect after a PKCE Required response is received.\n  if (pkceStore.usePkce) {\n    return;\n  }\n\n  // Redirect to a provided path (check options first, then url querystring)\n  if (redirect) {\n    return redirectToPath(redirect);\n  } else if (getQueryAttr(\"redirect\")) {\n    return redirectToPath(getQueryAttr(\"redirect\"));\n  }\n\n  // If no path was provided, look up the path and then redirect there\n  try {\n    const { data } = await get(`/self`, {\n      headers: {\n        authorization: `Bearer ${store.tokens.accessToken}`,\n      },\n    });\n    if (data.tenant && data.tenant.loginRedirectPath) {\n      redirectToPath(data.tenant.loginRedirectPath);\n    }\n  } catch (err) {\n    removeAllCookies();\n  }\n}\n\n/**\n * If the access token is invalid, redirect the browser to the\n * provided path.\n */\nexport async function redirectIfLoggedOut({ redirect } = {}) {\n  // If the user is logged in, return without doing anything\n  const { isLoggedIn } = await getSession();\n  if (isLoggedIn) {\n    return;\n  }\n\n  // Remove all cookies\n  removeAllCookies();\n\n  // Redirect to a provided path (check options first, then url querystring)\n  if (redirect) {\n    return redirectToPath(redirect);\n  } else if (getQueryAttr(\"redirect\")) {\n    return redirectToPath(getQueryAttr(\"redirect\"));\n  }\n\n  // If no redirect path was provided, do not redirect\n  return;\n}\n\n/**\n * Redirect to path portion of a URL.\n */\nexport function redirectToPath(pathOrUrl) {\n  // Return if no pathOrUrl, or if SSR or mobile\n  if (\n    !pathOrUrl ||\n    typeof document !== \"object\" ||\n    typeof window !== \"object\"\n  ) {\n    return;\n  }\n  try {\n    document && window;\n  } catch (error) {\n    return;\n  }\n\n  // Perform hard redirect\n  const el = document.createElement(\"a\");\n  el.href = pathOrUrl;\n  let path = `${el.pathname}${el.hash}${el.search}`;\n  if (el.pathname !== window.location.pathname) {\n    window.location.assign(path);\n  }\n}\n","import { defaultHandleTokens, setTokensFromCookies } from \"./tokens.js\";\nimport { setCookie } from \"./cookies.js\";\nimport { defaultHandleRedirect, getQueryAttr } from \"./url.js\";\nimport { defaultHandlePkceRequired } from \"./pkce.js\";\nimport { defaultHandleMfaRequired } from \"./mfa.js\";\n\n// Data specific to the MFA service\nexport const authenticationData = {\n  firstFactors: [],\n  secondFactors: [],\n  firstFactorToken: null,\n};\n\n/**\n * Set the cookies from a tokens object, and add to the local store.\n * @param {Object} tokens\n */\nexport function setCookiesAndTokens(tokens) {\n  setCookie(tokens.access.value, tokens.access.cookieOptions, \"access\");\n  setCookie(tokens.id.value, tokens.id.cookieOptions, \"id\");\n  if (tokens.refresh && tokens.refresh.value) {\n    setCookie(tokens.refresh.value, tokens.refresh.cookieOptions, \"refresh\");\n  }\n  setTokensFromCookies();\n}\n\n/**\n * Handle the API response for an authentication request\n * @property {Object} data\n * @property {String|Boolean} redirect\n * @property {Function} handleUpstreamResponse\n * @property {Function} handleMfaRequired\n * @property {Function} handlePkceRequired\n * @property {Function} handleTokens\n * @property {Function} handleRedirect\n * @returns {Object} data (or redirection)\n */\nexport async function handleLoginResponse({\n  data,\n  redirect,\n  handleUpstreamResponse,\n  handleMfaRequired,\n  handlePkceRequired,\n  handleTokens,\n  handleRedirect,\n}) {\n  let redirectValue =\n    redirect || getQueryAttr(\"redirect\") || data.redirectTo || \"/\";\n\n  // Handle upstreamResponse\n  if (typeof handleUpstreamResponse === \"function\") {\n    await handleUpstreamResponse(data.upstreamResponse, data);\n  }\n\n  // Handle \"MFA required\" response\n  if (data.hasOwnProperty(\"firstFactorToken\")) {\n    if (typeof handleMfaRequired === \"function\") {\n      await handleMfaRequired(data.firstFactorToken, data);\n    } else {\n      defaultHandleMfaRequired(data.firstFactorToken, data);\n    }\n    return data;\n  }\n\n  // Handle tokens\n  if (data.hasOwnProperty(\"tokens\")) {\n    if (typeof handleTokens === \"function\") {\n      await handleTokens(data.tokens, data);\n    } else {\n      await defaultHandleTokens(data.tokens, data);\n    }\n  }\n\n  // Handle \"PKCE required\" response\n  if (data.hasOwnProperty(\"authorizationCode\")) {\n    if (!redirectValue) {\n      throw new Error(\"Missing PKCE redirect url\");\n    }\n    if (typeof handlePkceRequired === \"function\") {\n      await handlePkceRequired(data.authorizationCode, redirectValue, data);\n    } else {\n      defaultHandlePkceRequired(data.authorizationCode, redirectValue, data);\n      return data;\n    }\n  }\n\n  // Handle redirection\n  if (data.hasOwnProperty(\"redirectTo\") && redirect !== false) {\n    if (typeof handleRedirect === \"function\") {\n      await handleRedirect(redirectValue, data);\n    } else {\n      defaultHandleRedirect(redirectValue, data);\n    }\n  }\n\n  return data;\n}\n","import Cookies from \"js-cookie\";\nimport { get } from \"./api.js\";\nimport { setCookiesAndTokens } from \"./authentication.js\";\nimport { store } from \"./store.js\";\n// import { getIframe, postMessageAsPromise } from \"./iframe.js\";\nimport { throwFormattedError } from \"./utils.js\";\n\n/**\n * Refresh the access and ID tokens\n * - When in test mode, uses the basic refresh method\n * - For tenants without a custom SSL certificate, uses the basic refresh method\n * - For tenants with a custom SSL certificate and in live mode, uses the httpOnly refresh method\n * @returns {Promise}\n */\nexport async function refresh() {\n  try {\n    await basicRefresh();\n  } catch (error) {\n    console.warn(`Refresh failed: ${error.message}`);\n  }\n}\n\n/**\n * Use a regular (non-httpOnly) cookie to refresh the access and ID tokens.\n *\n * The basic refresh method is used automatically in test mode and in live\n * mode whenever an SSL certificate has not been set up.\n */\nasync function basicRefresh() {\n  const refreshToken = Cookies.get(store.tokens.refreshTokenName);\n  try {\n    const { data, status } = await get(`/auth/refresh`, {\n      headers: {\n        authorization: `Bearer ${refreshToken}`,\n      },\n    });\n    if (status !== 200) {\n      throw new Error(data.message || \"Problem with request\");\n    }\n    if (data.tokens) {\n      setCookiesAndTokens(data.tokens);\n      return data;\n    } else {\n      throw new Error(\"Problem setting cookies\");\n    }\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n\n// TODO re-enable httpOnly refresh method once new endpoints are stable [06/15/21]\n/**\n *\n * The httpOnly refresh method is only available for tenants with configured\n * SSL certificates while in live mode.\n */\n// async function httpOnlyRefresh() {\n//   const iframe = getIframe();\n//   if (!iframe) return;\n//   return postMessageAsPromise({\n//     type: \"refresh\",\n//     tenantId: store.tenantId,\n//   });\n// }\n\n/**\n * Use a sessionId and nonce to set the iframe refresh token\n * @param {String} sessionId\n * @param {String} nonce\n * @returns {Promise}\n */\nexport async function exchange({ sessionId, nonce }) {\n  return;\n\n  // TODO re-enable httpOnly exchange method once new endpoints are stable [06/15/21]\n  // --------------------------\n  // const iframe = getIframe();\n  // if (!iframe) return;\n  // return postMessageAsPromise({\n  //   type: \"exchange\",\n  //   tenantId: store.tenantId,\n  //   payload: {\n  //     sessionId,\n  //     nonce,\n  //   },\n  // });\n}\n","import { post, put } from \"./api.js\";\nimport { setCookiesAndTokens } from \"./authentication.js\";\nimport { store } from \"./store.js\";\nimport { getQueryAttr, defaultHandleRedirect } from \"./url.js\";\nimport { throwFormattedError } from \"./utils.js\";\nimport { handleLoginResponse } from \"./authentication.js\";\nimport { getMfaHeaders } from \"./mfa.js\";\nimport { getPkceRequestQueryParams } from \"./pkce.js\";\n\n/**\n * Register a new user with username, name, email, and password.\n * Redirect the browser after successful signup based on the redirectTo value returned.\n * @property {String} username\n * @property {String} name\n * @property {String} email\n * @property {String} password\n * @property {Object} userData - alias for the user.data object, since \"data\" is used in the response\n * @property {String} redirect - do not redirect if false, or redirect to a specific path\n * @property {Function} handleUpstreamResponse\n * @property {Function} handleMfaRequired\n * @property {Function} handlePkceRequired\n * @property {Function} handleTokens\n * @property {Function} handleRedirect\n */\nexport async function signupWithPassword({\n  username,\n  name,\n  email,\n  password,\n  userData,\n  redirect,\n  handleUpstreamResponse,\n  handleMfaRequired,\n  handlePkceRequired,\n  handleTokens,\n  handleRedirect,\n} = {}) {\n  try {\n    const { data } = await post(\n      `/auth/create`,\n      {\n        tenantId: store.tenantId,\n        username,\n        name,\n        email,\n        password,\n        data: userData,\n      },\n      {\n        headers: getMfaHeaders(),\n        params: getPkceRequestQueryParams(),\n      }\n    );\n\n    // Handle the API response to the login request\n    return handleLoginResponse({\n      data,\n      redirect,\n      handleUpstreamResponse,\n      handleMfaRequired,\n      handlePkceRequired,\n      handleTokens,\n      handleRedirect,\n    });\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n\n/**\n * Log a user in with email/username and password.\n * Redirect the browser after successful login based on the redirectTo value returned.\n * @property {String} email The user's email. One of email/username/emailOrUsername should be present.\n * @property {String} username The user's username. One of email/username/emailOrUsername should be present.\n * @property {String} emailOrUsername Either the user's email or username. One of email/username/emailOrUsername should be present.\n * @property {String} password\n * @property {String|Boolean} redirect\n *  URL to redirect to after login, or false to suppress redirect. Otherwise, redirects to the after-login path set on the server.\n * @property {Function} handleUpstreamResponse\n * @property {Function} handleMfaRequired\n * @property {Function} handlePkceRequired\n * @property {Function} handleTokens\n * @property {Function} handleRedirect\n * @property {Object} options\n * @property {Boolean} options.noResetEmail\n *  By default, Userfront sends a password reset email if a user without a password tries to log in with a password.\n *  Set options.noResetEmail = true to override this behavior and return an error instead.\n *\n */\nexport async function loginWithPassword({\n  email,\n  username,\n  emailOrUsername,\n  password,\n  redirect,\n  handleUpstreamResponse,\n  handleMfaRequired,\n  handlePkceRequired,\n  handleTokens,\n  handleRedirect,\n  options,\n}) {\n  try {\n    const body = {\n      tenantId: store.tenantId,\n      emailOrUsername: email || username || emailOrUsername,\n      password,\n    };\n    if (options && options.noResetEmail) {\n      body.options = {\n        noResetEmail: true,\n      };\n    }\n    const { data } = await post(`/auth/basic`, body, {\n      headers: getMfaHeaders(),\n      params: getPkceRequestQueryParams(),\n    });\n\n    // Handle the API response to the login request\n    return handleLoginResponse({\n      data,\n      redirect,\n      handleUpstreamResponse,\n      handleMfaRequired,\n      handlePkceRequired,\n      handleTokens,\n      handleRedirect,\n    });\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n\n/**\n * Send a password reset link to the provided email.\n * @param {String} email\n */\nexport async function sendResetLink(email) {\n  try {\n    const { data } = await post(`/auth/reset/link`, {\n      email,\n      tenantId: store.tenantId,\n    });\n    return data;\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n\n/**\n * Set a user's password with their link credentials or JWT access token.\n *\n * If no method is provided, the order is:\n * - Check for link credentials; then\n * - Check for a JWT access token first\n *\n * @property {String} method (optional) \"link\" or \"jwt\"\n * @property {String} password\n * @property {String} existingPassword\n * @property {String} uuid\n * @property {String} token\n * @property {String} redirect\n * @property {Function} handleUpstreamResponse - \n * @property {Function} handleMfaRequired\n * @property {Function} handlePkceRequired\n * @property {Function} handleTokens\n * @property {Function} handleRedirect\n * @returns\n */\nexport async function updatePassword({\n  method,\n  password,\n  existingPassword,\n  uuid,\n  token,\n  redirect,\n  handleUpstreamResponse,\n  handleMfaRequired,\n  handlePkceRequired,\n  handleTokens,\n  handleRedirect,\n}) {\n  switch (method) {\n    // Allow for explicit setting of method\n    case \"link\":\n      return updatePasswordWithLink({\n        uuid,\n        token,\n        password,\n        redirect,\n        handleUpstreamResponse,\n        handleMfaRequired,\n        handlePkceRequired,\n        handleTokens,\n        handleRedirect,\n      });\n    case \"jwt\":\n      return updatePasswordWithJwt({ password, existingPassword });\n    default:\n      // Default (no method provided) is to look for link credentials first, then JWT access token\n      token = token || getQueryAttr(\"token\");\n      uuid = uuid || getQueryAttr(\"uuid\");\n      if (uuid && token) {\n        return updatePasswordWithLink({\n          uuid,\n          token,\n          password,\n          redirect,\n          handleUpstreamResponse,\n          handleMfaRequired,\n          handlePkceRequired,\n          handleTokens,\n          handleRedirect,\n        });\n      } else if (store.tokens.accessToken) {\n        return updatePasswordWithJwt({ password, existingPassword });\n      } else {\n        throw new Error(\n          \"updatePassword() was called without link credentials (token & uuid) or a JWT access token.\"\n        );\n      }\n  }\n}\n\nexport const resetPassword = updatePassword;\n\nexport async function updatePasswordWithLink({\n  uuid,\n  token,\n  password,\n  redirect,\n  handleUpstreamResponse,\n  handleMfaRequired,\n  handlePkceRequired,\n  handleTokens,\n  handleRedirect,\n}) {\n  try {\n    token = token || getQueryAttr(\"token\");\n    uuid = uuid || getQueryAttr(\"uuid\");\n    if (!token || !uuid) throw new Error(\"Missing token or uuid\");\n    const { data } = await put(`/auth/reset`, {\n      tenantId: store.tenantId,\n      uuid,\n      token,\n      password,\n    });\n    return handleLoginResponse({\n      data,\n      redirect,\n      handleUpstreamResponse,\n      handleMfaRequired,\n      handlePkceRequired,\n      handleTokens,\n      handleRedirect,\n    });\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n\nexport async function updatePasswordWithJwt({ password, existingPassword }) {\n  try {\n    if (!store.tokens.accessToken) {\n      throw new Error(\n        `updatePassword({ method: \"jwt\" }) was called without a JWT access token.`\n      );\n    }\n\n    const { data } = await put(\n      `/auth/basic`,\n      {\n        tenantId: store.tenantId,\n        password,\n        existingPassword,\n      },\n      {\n        headers: {\n          Authorization: `Bearer ${store.tokens.accessToken}`,\n        },\n      }\n    );\n\n    return data;\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n","import { store } from \"./store.js\";\nimport { getQueryAttr } from \"./url.js\";\n\nexport function getProviderLink({ provider, redirect }) {\n  if (!provider) throw new Error(\"Missing provider\");\n  if (!store.tenantId) throw new Error(\"Missing tenantId\");\n\n  let url = `${store.baseUrl}auth/${provider}/login?tenant_id=${store.tenantId}&origin=${window.location.origin}`;\n\n  let redirectTo = redirect || getQueryAttr(\"redirect\");\n  if (redirect === false) {\n    redirectTo = typeof document === \"object\" && document.location.pathname;\n  }\n  if (redirectTo) {\n    url += `&redirect=${encodeURIComponent(redirectTo)}`;\n  }\n\n  return url;\n}\n\n/**\n * Log in or register a user via SSO provider.\n * Redirect the browser after successful authentication and 302 redirect from server.\n * @param {String} provider Name of SSO provider\n * @param {String} redirect - do not redirect if false, or redirect to given path\n */\nexport function signonWithSso({ provider, redirect }) {\n  if (!provider) throw new Error(\"Missing provider\");\n  const url = getProviderLink({ provider, redirect });\n  window.location.assign(url);\n}\n","import { post, put } from \"./api.js\";\nimport { store } from \"./store.js\";\nimport { getQueryAttr } from \"./url.js\";\nimport { throwFormattedError } from \"./utils.js\";\nimport { handleLoginResponse } from \"./authentication.js\";\nimport { getMfaHeaders } from \"./mfa.js\";\nimport { getPkceRequestQueryParams } from \"./pkce.js\";\n\n/**\n * Log a user in with a token/uuid combo passed into the function or\n * in the URL querystring. ?token=...&uuid=...\n * @property {String} token\n * @property {UUID} uuid\n * @property {String} redirect - do not redirect if false, or redirect to given path\n * @property {Function} handleUpstreamResponse\n * @property {Function} handleMfaRequired\n * @property {Function} handlePkceRequired\n * @property {Function} handleTokens\n * @property {Function} handleRedirect\n */\nexport async function loginWithLink({\n  token,\n  uuid,\n  redirect,\n  handleUpstreamResponse,\n  handleMfaRequired,\n  handlePkceRequired,\n  handleTokens,\n  handleRedirect,\n} = {}) {\n  try {\n    token = token || getQueryAttr(\"token\");\n    uuid = uuid || getQueryAttr(\"uuid\");\n    if (!token || !uuid) return;\n\n    const { data } = await put(\n      \"/auth/link\",\n      {\n        token,\n        uuid,\n        tenantId: store.tenantId,\n      },\n      {\n        headers: getMfaHeaders(),\n        params: getPkceRequestQueryParams(),\n      }\n    );\n\n    // Handle the API response to the login request\n    return handleLoginResponse({\n      data,\n      redirect,\n      handleUpstreamResponse,\n      handleMfaRequired,\n      handlePkceRequired,\n      handleTokens,\n      handleRedirect,\n    });\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n\n/**\n * Send a login link to the provided email.\n * @param {String} email\n */\nexport async function sendLoginLink(email) {\n  try {\n    const { data } = await post(`/auth/link`, {\n      email,\n      tenantId: store.tenantId,\n    });\n    return data;\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n\n/**\n * Create or update a user and send them a link to log in.\n * @param {Object} inputs\n */\nexport async function sendPasswordlessLink({\n  email,\n  name,\n  username,\n  userData,\n  options,\n}) {\n  try {\n    const { data } = await post(`/auth/link`, {\n      email,\n      name,\n      username,\n      data: userData,\n      options,\n      tenantId: store.tenantId,\n    });\n    return data;\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n","import { post, put } from \"./api.js\";\nimport { store } from \"./store.js\";\nimport { throwFormattedError } from \"./utils.js\";\nimport { handleLoginResponse } from \"./authentication.js\";\nimport { getMfaHeaders, isFirstFactorTokenPresent } from \"./mfa.js\";\nimport { getPkceRequestQueryParams } from \"./pkce.js\";\n\n/**\n * Verify that proper identifier is available for the channel\n * @property {String} channel \"sms\" or \"email\"\n * @property {String} phoneNumber\n * @property {String} email\n */\nfunction enforceChannel({ channel, phoneNumber, email }) {\n  // Enforce valid channels\n  if (channel !== \"sms\" && channel !== \"email\") {\n    throw new Error(\"Invalid channel\");\n  }\n\n  // Do not require phoneNumber or email when firstFactorToken is included\n  if (isFirstFactorTokenPresent()) {\n    return;\n  }\n\n  // Check that phoneNumber or email are present if needed\n  if (channel === \"sms\" && !phoneNumber) {\n    throw new Error(`SMS verification code requires \"phoneNumber\"`);\n  } else if (channel === \"email\" && !email) {\n    throw new Error(`Email verification code requires \"email\"`);\n  }\n}\n\n/**\n * Send a verification code to the provided email address or phone number.\n * @property {String} channel \"sms\" (default) or \"email\"\n * @property {String} phoneNumber\n * @property {String} email\n * @property {String} name\n * @property {String} username\n * @property {Object} data\n */\nexport async function sendVerificationCode({\n  channel = \"sms\",\n  phoneNumber,\n  email,\n  name,\n  username,\n  data,\n}) {\n  try {\n    enforceChannel({\n      channel,\n      phoneNumber,\n      email,\n    });\n\n    const { data: res } = await post(\n      `/auth/code`,\n      {\n        channel,\n        email,\n        phoneNumber,\n        name,\n        username,\n        data,\n        tenantId: store.tenantId,\n      },\n      {\n        headers: getMfaHeaders(),\n      }\n    );\n    return res;\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n\n/**\n * Log a user in with a token/uuid combo passed into the function or\n * in the URL querystring. ?token=...&uuid=...\n * @param {String} token\n * @param {UUID} uuid\n * @param {String} redirect - do not redirect if false, or redirect to given path\n */\nexport async function loginWithVerificationCode({\n  channel,\n  verificationCode,\n  email,\n  phoneNumber,\n  redirect,\n  handleUpstreamResponse,\n  handleMfaRequired,\n  handlePkceRequired,\n  handleTokens,\n  handleRedirect,\n} = {}) {\n  try {\n    enforceChannel({\n      channel,\n      phoneNumber,\n      email,\n    });\n\n    const { data } = await put(\n      `/auth/code`,\n      {\n        channel,\n        verificationCode,\n        email,\n        phoneNumber,\n        tenantId: store.tenantId,\n      },\n      {\n        headers: getMfaHeaders(),\n        params: getPkceRequestQueryParams(),\n      }\n    );\n\n    // Handle the API response to the login request\n    return handleLoginResponse({\n      data,\n      redirect,\n      handleUpstreamResponse,\n      handleMfaRequired,\n      handlePkceRequired,\n      handleTokens,\n      handleRedirect,\n    });\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n","import { get, post } from \"./api.js\";\nimport { store } from \"./store.js\";\nimport { throwFormattedError } from \"./utils.js\";\nimport { handleLoginResponse } from \"./authentication.js\";\nimport { isFirstFactorTokenPresent, getMfaHeaders } from \"./mfa.js\";\nimport { getPkceRequestQueryParams } from \"./pkce.js\";\n\n/**\n * Log a user in with a TOTP authenticator code or a TOTP backup code,\n * plus an identifier for the user (e.g. userId, userUuid, or email)\n *\n * @property {String} totpCode \"123456\"\n * @property {String} backupCode \"aaaaa-bbbbb\"\n * @property {Integer} userId\n * @property {String} userUuid\n * @property {String} emailOrUsername\n * @property {String} email\n * @property {String} username\n * @property {String} phoneNumber\n * @property {String|Boolean} redirect - do not redirect if false, or redirect to given path\n */\nexport async function loginWithTotp({\n  totpCode,\n  backupCode,\n  userId,\n  userUuid,\n  emailOrUsername,\n  email,\n  username,\n  phoneNumber,\n  redirect,\n  handleUpstreamResponse,\n  handleMfaRequired,\n  handlePkceRequired,\n  handleTokens,\n  handleRedirect,\n} = {}) {\n  try {\n    const { data } = await post(\n      `/auth/totp`,\n      {\n        totpCode,\n        backupCode,\n        userId,\n        userUuid,\n        emailOrUsername,\n        email,\n        username,\n        phoneNumber,\n        tenantId: store.tenantId,\n      },\n      {\n        headers: getMfaHeaders(),\n        params: getPkceRequestQueryParams(),\n      }\n    );\n\n    // Handle the API response to the login request\n    return handleLoginResponse({\n      data,\n      redirect,\n      handleUpstreamResponse,\n      handleMfaRequired,\n      handlePkceRequired,\n      handleTokens,\n      handleRedirect,\n    });\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n\nexport async function getTotp() {\n  try {\n    if (isFirstFactorTokenPresent()) {\n      const { data } = await get(`/auth/totp`, {\n        headers: getMfaHeaders(),\n      });\n      return data;\n    }\n\n    if (!store.tokens.accessToken) {\n      throw new Error(`getTotp() was called without a JWT access token.`);\n    }\n\n    const { data } = await get(`/auth/totp`, {\n      headers: {\n        Authorization: `Bearer ${store.tokens.accessToken}`,\n      },\n    });\n\n    return data;\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n","import { get } from \"./api.js\";\nimport { getIframe, postMessageAsPromise } from \"./iframe.js\";\nimport { store } from \"./store.js\";\nimport { removeAllCookies } from \"./cookies.js\";\nimport { setTokensFromCookies } from \"./tokens.js\";\nimport { defaultHandleRedirect } from \"./url\";\nimport { throwFormattedError } from \"./utils.js\";\n\n/**\n * Log a user out and redirect to the logout path.\n */\nexport async function logout({ method, redirect } = {}) {\n  if (method === \"saml\") {\n    return completeSamlLogout();\n  }\n  if (!store.tokens.accessToken) {\n    return removeAllCookies();\n  }\n\n  try {\n    const { data } = await get(`/auth/logout`, {\n      headers: {\n        authorization: `Bearer ${store.tokens.accessToken}`,\n      },\n    });\n    removeAllCookies();\n    defaultHandleRedirect(redirect, data);\n  } catch (err) {\n    removeAllCookies();\n  }\n}\n\nasync function completeSamlLogout() {\n  if (!store.tokens.accessToken) {\n    throw new Error(\"Please log in to authorize your logout request.\");\n  }\n\n  try {\n    const { data } = await get(`/auth/saml/idp/token`, {\n      headers: {\n        authorization: `Bearer ${store.tokens.accessToken}`,\n      },\n    });\n\n    window.location.assign(\n      `${store.baseUrl}auth/saml/idp/logout?tenant_id=${store.tenantId}&token=${data.token}&uuid=${store.user.userUuid}`\n    );\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n\n// TODO re-enable exchange method once new endpoints are stable [06/15/21]\n// --------------------------\n// const iframe = getIframe();\n// if (!iframe) return;\n// try {\n//   const { data } = await postMessageAsPromise({\n//     type: \"logout\",\n//     tenantId: store.tenantId,\n//   });\n//   removeAllCookies();\n//   setTokensFromCookies();\n//   defaultHandleRedirect(redirect, data);\n// } catch (error) {\n//   removeAllCookies();\n//   redirectToPath(\"/\");\n// }\n","export const apiUrl = `https://api.userfront.com/v0/`;\n\nexport const privateIPRegex =\n  /((^127\\.)|(^10\\.)|(^172\\.1[6-9]\\.)|(^172\\.2[0-9]\\.)|(^172\\.3[0-1]\\.)|(^192\\.168\\.))\\d{1,3}\\.\\d{1,3}/g;\n","import { get } from \"./api.js\";\nimport { privateIPRegex } from \"./constants.js\";\nimport { store } from \"./store.js\";\nimport { setFirstFactors } from \"./mfa.js\";\n\n/**\n * Global mode object\n */\nexport const mode = {\n  value: \"live\",\n  reason: undefined,\n  setMode,\n};\n\nsetModeSync();\n\n/**\n * Determine whether a hostname is in test mode.\n * @param {String} hn\n */\nexport function isTestHostname(hn) {\n  try {\n    const hostname = hn || window.location.hostname;\n    return !!(hostname.match(/localhost/g) || hostname.match(privateIPRegex));\n  } catch (err) {\n    return true;\n  }\n}\n\nexport function isHttps() {\n  try {\n    return window.location.protocol === \"https:\";\n  } catch (error) {\n    return false;\n  }\n}\n\n/**\n * Define the mode of operation (live or test)\n * and the tenant's authentication factors\n */\nexport async function setMode() {\n  try {\n    const { data } = await get(`/tenants/${store.tenantId}/mode`);\n    mode.value = data.mode || \"test\";\n    mode.reason = getReason(mode.value);\n    store.mode = mode.value;\n    setFirstFactors(data.authentication);\n    return data;\n  } catch (err) {\n    mode.value = \"test\";\n    store.mode = mode.value;\n  }\n}\n\n/**\n * Estimate the mode without making an API call\n */\nexport function setModeSync() {\n  const modeValue = isTestHostname() || !isHttps() ? \"test\" : \"live\";\n  mode.value = modeValue;\n  mode.reason = getReason(modeValue);\n  store.mode = modeValue;\n}\n\n/**\n * Set the reason for the mode\n * - http\n * - domain\n */\nfunction getReason(mode) {\n  try {\n    if (mode === \"live\") {\n      return \"domain\";\n    }\n    if (window.location.protocol === \"http:\") {\n      return \"http\";\n    } else if (window.location.protocol !== \"https:\") {\n      return \"protocol\";\n    } else {\n      return \"domain\";\n    }\n  } catch (error) {}\n}\n","/**\n * user methods are refactored into a separate file to avoid a circular dependency\n * between Userfront.refresh() [which requires setUser()]\n * and Userfront.user.update() [which requires refresh()].\n */\nimport { put } from \"./api.js\";\nimport { store } from \"./store.js\";\nimport { refresh } from \"./refresh.js\";\nimport { getTotp } from \"./totp.js\";\nimport { getJwtPayload } from \"./utils.js\";\nimport { updatePassword } from \"./password.js\";\n\n/**\n * Update the user record on Userfront\n * @param {Object} payload User properties to update e.g. { name: 'John Doe' }\n */\nexport async function update(payload) {\n  if (!payload || Object.keys(payload).length < 1) {\n    return console.warn(\"Missing user properties to update\");\n  }\n\n  // Make request to update the user\n  await put(`/self`, payload, {\n    headers: {\n      authorization: `Bearer ${store.tokens.accessToken}`,\n    },\n  });\n\n  // Refresh the access and ID tokens, and set the store.user object from the ID token\n  await refresh();\n\n  return store.user;\n}\n\n/**\n * Determine whether the access token has a given role\n * @param {String} roleName\n * @param {Object} options\n * @returns {Boolean}\n */\nexport function hasRole(roleName, { tenantId } = {}) {\n  try {\n    if (!store.tokens.accessToken || !store.tenantId) {\n      return false;\n    }\n    const { authorization } = getJwtPayload(store.tokens.accessToken);\n    if (!authorization) {\n      return false;\n    }\n    tenantId = tenantId || store.tenantId;\n    if (!authorization[tenantId] || !authorization[tenantId].roles) {\n      return false;\n    }\n    return authorization[tenantId].roles.indexOf(roleName) > -1;\n  } catch (error) {\n    return false;\n  }\n}\n\n/**\n * Add the methods to the store.user object\n */\nstore.user.update = update;\nstore.user.hasRole = hasRole;\nstore.user.updatePassword = updatePassword;\nstore.user.getTotp = getTotp;\n","import axios from \"axios\";\nimport { store } from \"./store.js\";\nimport {\n  tokens,\n  accessToken,\n  idToken,\n  setTokensFromCookies,\n  setTokenNames,\n} from \"./tokens\";\nimport { getSession } from \"./session\";\nimport { redirectIfLoggedIn, redirectIfLoggedOut } from \"./url.js\";\nimport { signup } from \"./signup.js\";\nimport { login } from \"./login.js\";\nimport { updatePassword, resetPassword, sendResetLink } from \"./password.js\";\nimport { sendLoginLink } from \"./link.js\";\nimport { sendVerificationCode } from \"./verificationCode\";\nimport { logout } from \"./logout.js\";\nimport { mode, setMode, setModeSync } from \"./mode.js\";\n// import { setIframe } from \"./iframe.js\";\nimport { user } from \"./user.js\";\nimport \"./user.methods.js\";\nimport { refresh } from \"./refresh.js\";\nimport { apiUrl } from \"./constants.js\";\nimport { resetMfa } from \"./mfa.js\";\n\nlet initCallbacks = [];\n\n/**\n * Initialize the Userfront library.\n * @param {String} tenantId\n */\nfunction init(tenantId, opts = {}) {\n  if (!tenantId) return console.warn(\"Userfront initialized without tenantId\");\n\n  store.tenantId = tenantId;\n\n  store.baseUrl = opts.baseUrl || apiUrl;\n  if (!store.baseUrl.endsWith(\"/\")) {\n    store.baseUrl += \"/\";\n  }\n\n  if (opts.domain) {\n    store.domain = opts.domain;\n    const url = `https://${store.domain}`;\n    axios.defaults.headers.common[\"x-application-id\"] = url;\n    axios.defaults.headers.common[\"x-origin\"] = url;\n  }\n\n  setTokenNames();\n  // setIframe(); // TODO re-enable when iframe is needed\n  setTokensFromCookies();\n\n  // Estimate the mode synchronously with local data.\n  // Clients that require the true mode or the default\n  // authenticationData should call and await setMode.\n  setModeSync();\n\n  resetMfa();\n\n  try {\n    if (initCallbacks.length > 0) {\n      initCallbacks.forEach((cb) => {\n        if (!cb || typeof cb !== \"function\") return;\n        cb({ tenantId });\n      });\n    }\n    initCallbacks = [];\n  } catch (error) {}\n}\n\n/**\n * Add a callback function to be called upon Userfront.init()\n * @param {Function} cb\n */\nfunction addInitCallback(cb) {\n  if (!cb || typeof cb !== \"function\") return;\n  initCallbacks.push(cb);\n}\n\n/**\n\n * Register a window-level event called \"urlchanged\" that will fire\n * whenever the browser URL changes.\n */\nlet isRegistered = false;\nfunction registerUrlChangedEventListener() {\n  if (isRegistered) return;\n  isRegistered = true;\n  try {\n    history.pushState = ((f) =>\n      function pushState() {\n        var ret = f.apply(this, arguments);\n        window.dispatchEvent(new Event(\"pushstate\"));\n        window.dispatchEvent(new Event(\"urlchanged\"));\n        return ret;\n      })(history.pushState);\n\n    history.replaceState = ((f) =>\n      function replaceState() {\n        var ret = f.apply(this, arguments);\n        window.dispatchEvent(new Event(\"replacestate\"));\n        window.dispatchEvent(new Event(\"urlchanged\"));\n        return ret;\n      })(history.replaceState);\n\n    window.addEventListener(\"popstate\", () => {\n      window.dispatchEvent(new Event(\"urlchanged\"));\n    });\n  } catch (error) {}\n}\n\n/**\n * EXPORTS\n */\n\nexport default {\n  // index\n  addInitCallback,\n  init,\n  registerUrlChangedEventListener,\n\n  //logout\n  logout,\n\n  // mode\n  mode,\n  setMode,\n\n  // refresh\n  refresh: (a, b, c) => {\n    try {\n      console.warn(\n        \"Userfront.refresh() is deprecated and will be removed. Please use Userfront.tokens.refresh() instead.\"\n      );\n    } catch (error) {}\n    return refresh(a, b, c);\n  },\n\n  // signon\n  login,\n  resetPassword,\n  updatePassword,\n  sendLoginLink,\n  sendResetLink,\n  sendVerificationCode,\n  signup,\n\n  // store\n  store,\n\n  // tokens\n  tokens,\n  accessToken,\n  idToken,\n\n  // session\n  getSession,\n\n  // url\n  redirectIfLoggedIn,\n  redirectIfLoggedOut,\n\n  // user\n  user,\n\n  // utils\n};\n","import { loginWithPassword } from \"./password.js\";\nimport { loginWithPasswordMigrate } from \"./password.migrate.js\";\nimport { loginWithLink, sendPasswordlessLink } from \"./link.js\";\nimport { signonWithSso } from \"./sso.js\";\nimport { loginWithTotp } from \"./totp.js\";\nimport { loginWithVerificationCode } from \"./verificationCode.js\";\nimport { completeSamlLogin } from \"./saml.js\";\nimport { setupPkce } from \"./pkce.js\";\n\n/**\n * Log a user in via the provided method. This method serves to call other\n * methods, depending on the \"method\" parameter passed in.\n * @property {String} method\n * @property {Number} userId\n * @property {String} userUuid\n * @property {String} email\n * @property {String} username\n * @property {String} emailOrUsername\n * @property {String} phoneNumber\n * @property {String} password\n * @property {String} token\n * @property {String} uuid\n * @property {String} totpCode\n * @property {String} backupCode\n * @property {String} channel \"sms\" or \"email\"\n * @property {String} verificationCode\n * @property {String | Boolean} redirect - do not redirect if false, or redirect to given path\n * @property {Function} handleUpstreamResponse\n * @property {Function} handleMfaRequired\n * @property {Function} handlePkceRequired\n * @property {Function} handleTokens\n * @property {Function} handleRedirect\n */\nexport async function login({\n  method,\n  // User identifiers\n  userId,\n  userUuid,\n  email,\n  username,\n  emailOrUsername,\n  phoneNumber,\n  // Password\n  password,\n  // Link\n  token,\n  uuid,\n  // Totp\n  totpCode,\n  backupCode,\n  // Verification code\n  channel,\n  verificationCode,\n  // Other\n  redirect,\n  handleUpstreamResponse,\n  handleMfaRequired,\n  handlePkceRequired,\n  handleTokens,\n  handleRedirect,\n  options,\n} = {}) {\n  if (!method) {\n    throw new Error('Userfront.login called without \"method\" property.');\n  }\n  setupPkce();\n  switch (method) {\n    case \"apple\":\n    case \"azure\":\n    case \"facebook\":\n    case \"github\":\n    case \"google\":\n    case \"linkedin\":\n    case \"okta\":\n      return signonWithSso({ provider: method, redirect });\n    case \"password\":\n      return loginWithPassword({\n        email,\n        username,\n        emailOrUsername,\n        password,\n        redirect,\n        handleUpstreamResponse,\n        handleMfaRequired,\n        handlePkceRequired,\n        handleTokens,\n        handleRedirect,\n        options,\n      });\n    case \"password-migrate\":\n      return loginWithPasswordMigrate({\n        email,\n        username,\n        emailOrUsername,\n        password,\n        redirect,\n        handleUpstreamResponse,\n        handleMfaRequired,\n        handlePkceRequired,\n        handleTokens,\n        handleRedirect,\n        options,\n      });\n    case \"passwordless\":\n      return sendPasswordlessLink({ email });\n    case \"link\":\n      return loginWithLink({\n        token,\n        uuid,\n        redirect,\n        handleUpstreamResponse,\n        handleMfaRequired,\n        handlePkceRequired,\n        handleTokens,\n        handleRedirect,\n      });\n    case \"totp\":\n      return loginWithTotp({\n        totpCode,\n        backupCode,\n        userId,\n        userUuid,\n        emailOrUsername,\n        email,\n        username,\n        phoneNumber,\n        redirect,\n        handleUpstreamResponse,\n        handleMfaRequired,\n        handlePkceRequired,\n        handleTokens,\n        handleRedirect,\n      });\n    case \"verificationCode\":\n      return loginWithVerificationCode({\n        channel,\n        email,\n        phoneNumber,\n        verificationCode,\n        redirect,\n        handleUpstreamResponse,\n        handleMfaRequired,\n        handlePkceRequired,\n        handleTokens,\n        handleRedirect,\n      });\n    case \"saml\":\n      return completeSamlLogin();\n    default:\n      throw new Error('Userfront.login called with invalid \"method\" property.');\n  }\n}\n","import { post } from \"./api.js\";\nimport { store } from \"./store.js\";\nimport { throwFormattedError } from \"./utils.js\";\nimport { handleLoginResponse } from \"./authentication.js\";\nimport { getMfaHeaders } from \"./mfa.js\";\nimport { getPkceRequestQueryParams } from \"./pkce.js\";\n\n/**\n * Log a user in with email/username and password using the password/migrate endpoint.\n * Redirect the browser after successful login based on the redirectTo value returned.\n * @property {String} email The user's email. One of email/username/emailOrUsername should be present.\n * @property {String} username The user's username. One of email/username/emailOrUsername should be present.\n * @property {String} emailOrUsername Either the user's email or username. One of email/username/emailOrUsername should be present.\n * @property {String} password\n * @property {String|Boolean} redirect\n *  URL to redirect to after login, or false to suppress redirect. Otherwise, redirects to the after-login path set on the server.\n * @property {Function} handleUpstreamResponse\n * @property {Function} handleMfaRequired\n * @property {Function} handlePkceRequired\n * @property {Function} handleTokens\n * @property {Function} handleRedirect\n * @property {Object} options\n * @property {Boolean} options.noResetEmail\n *  By default, Userfront sends a password reset email if a user without a password tries to log in with a password.\n *  Set options.noResetEmail = true to override this behavior and return an error instead.\n *\n */\nexport async function loginWithPasswordMigrate({\n  email,\n  username,\n  emailOrUsername,\n  password,\n  redirect,\n  handleUpstreamResponse,\n  handleMfaRequired,\n  handlePkceRequired,\n  handleTokens,\n  handleRedirect,\n  options,\n}) {\n  try {\n    const body = {\n      tenantId: store.tenantId,\n      emailOrUsername: email || username || emailOrUsername,\n      password,\n    };\n    if (options && options.noResetEmail) {\n      body.options = {\n        noResetEmail: true,\n      };\n    }\n\n    // Make the request to password/migrate\n    const { data } = await post(`/auth/password/migrate`, body, {\n      headers: getMfaHeaders(),\n      params: getPkceRequestQueryParams(),\n    });\n\n    // Handle the API response to the login request\n    return handleLoginResponse({\n      data,\n      redirect,\n      handleUpstreamResponse,\n      handleMfaRequired,\n      handlePkceRequired,\n      handleTokens,\n      handleRedirect,\n    });\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n","import { get } from \"./api.js\";\nimport { store } from \"./store.js\";\nimport { throwFormattedError } from \"./utils.js\";\n\nexport async function completeSamlLogin() {\n  try {\n    if (!store.tokens.accessToken) {\n      return console.warn(\"Cannot complete SAML login without access token\");\n    }\n\n    const { data } = await get(`/auth/saml/idp/token`, {\n      headers: {\n        authorization: `Bearer ${store.tokens.accessToken}`,\n      },\n    });\n\n    window.location.assign(\n      `${store.baseUrl}auth/saml/idp/login?tenant_id=${store.tenantId}&token=${data.token}&uuid=${store.user.userUuid}`\n    );\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n","import { signupWithPassword } from \"./password.js\";\nimport { signonWithSso } from \"./sso.js\";\nimport { sendPasswordlessLink } from \"./link.js\";\nimport { sendVerificationCode } from \"./verificationCode.js\";\nimport { setupPkce } from \"./pkce.js\";\n\n/**\n * Register a user via the provided method. This method serves to call other\n * methods, depending on the \"method\" parameter passed in.\n * @property {String} method\n * @property {String} email\n * @property {String} username\n * @property {String} phoneNumber\n * @property {String} name\n * @property {Object} data - Object for custom user fields\n * @property {String} password\n * @property {String} channel \"sms\" or \"email\"\n * @property {String} redirect - do not redirect if false, or redirect to given path\n * @property {Function} handleUpstreamResponse\n * @property {Function} handleMfaRequired\n * @property {Function} handlePkceRequired\n * @property {Function} handleTokens\n * @property {Function} handleRedirect\n */\nexport async function signup({\n  method,\n  email,\n  username,\n  phoneNumber,\n  name,\n  data,\n  password,\n  channel,\n  redirect,\n  handleUpstreamResponse,\n  handleMfaRequired,\n  handlePkceRequired,\n  handleTokens,\n  handleRedirect,\n} = {}) {\n  setupPkce();\n  if (!method) {\n    throw new Error('Userfront.signup called without \"method\" property.');\n  }\n  switch (method) {\n    case \"apple\":\n    case \"azure\":\n    case \"facebook\":\n    case \"github\":\n    case \"google\":\n    case \"linkedin\":\n    case \"okta\":\n      return signonWithSso({ provider: method, redirect });\n    case \"password\":\n      return signupWithPassword({\n        username,\n        name,\n        email,\n        password,\n        userData: data,\n        redirect,\n        handleUpstreamResponse,\n        handleMfaRequired,\n        handlePkceRequired,\n        handleTokens,\n        handleRedirect,\n      });\n    case \"passwordless\":\n      return sendPasswordlessLink({ email, name, username, userData: data });\n    case \"verificationCode\":\n      return sendVerificationCode({\n        channel,\n        email,\n        phoneNumber,\n        name,\n        username,\n        data,\n      });\n    default:\n      throw new Error(\n        'Userfront.signup called with invalid \"method\" property.'\n      );\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}